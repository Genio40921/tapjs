/// <reference types="node" />
import { TestArgs, TestBase, TestBaseOpts } from '@tapjs/core';
import { FinalResults } from 'tap-parser';
export declare const Plugin_stdin: import("@tapjs/core").TapPlugin<{
    "__#3@#private": any;
    stdin(name: string, extra?: import("@tapjs/core").StdinOpts | undefined): Promise<FinalResults | null>;
    stdin(extra?: import("@tapjs/core").StdinOpts | undefined): Promise<FinalResults | null>;
}, any>;
export declare const Plugin_spawn: import("@tapjs/core").TapPlugin<{
    "__#4@#private": any;
    spawn(cmd: string): Promise<FinalResults | null>;
    spawn(cmd: string, options: import("@tapjs/core/plugin/spawn.js").SpawnOpts, name?: string | undefined): Promise<FinalResults | null>;
    spawn(cmd: string, args: string | string[], name?: string | undefined): Promise<FinalResults | null>;
    spawn(cmd: string, args: string | string[], options: import("@tapjs/core/plugin/spawn.js").SpawnOpts, name?: string | undefined): Promise<FinalResults | null>;
}, any>;
export declare const Plugin_beforeEach: (t: TestBase) => {
    "__#5@#private": any;
    beforeEach(fn: (t: Test) => void | Promise<void>): void;
};
export declare const Plugin_afterEach: import("@tapjs/core").TapPlugin<{
    "__#6@#private": any;
    afterEach(fn: (t: Test) => void | Promise<void>): void;
}, any>;
export declare const Plugin_asserts: import("@tapjs/core").TapPlugin<{
    "__#7@#private": any;
    ok(obj: any, ...[msg, extra]: [] | [string] | [{
        [k: string]: any;
    }] | [string, {
        [k: string]: any;
    }]): boolean;
    notOk(obj: any, ...[msg, extra]: [] | [string] | [{
        [k: string]: any;
    }] | [string, {
        [k: string]: any;
    }]): boolean;
    equal(found: any, wanted: any, ...[msg, extra]: [] | [string] | [{
        [k: string]: any;
    }] | [string, {
        [k: string]: any;
    }]): boolean | undefined;
    not(found: any, doNotWant: any, ...[msg, extra]: [] | [string] | [{
        [k: string]: any;
    }] | [string, {
        [k: string]: any;
    }]): boolean;
    same(found: any, wanted: any, ...[msg, extra]: [] | [string] | [{
        [k: string]: any;
    }] | [string, {
        [k: string]: any;
    }]): boolean;
    notSame(found: any, doNotWant: any, ...[msg, extra]: [] | [string] | [{
        [k: string]: any;
    }] | [string, {
        [k: string]: any;
    }]): boolean;
    strictSame(found: any, wanted: any, ...[msg, extra]: [] | [string] | [{
        [k: string]: any;
    }] | [string, {
        [k: string]: any;
    }]): boolean;
    strictNotSame(found: any, doNotWant: any, ...[msg, extra]: [] | [string] | [{
        [k: string]: any;
    }] | [string, {
        [k: string]: any;
    }]): boolean;
    has(found: any, wanted: any, ...[msg, extra]: [] | [string] | [{
        [k: string]: any;
    }] | [string, {
        [k: string]: any;
    }]): boolean;
    notHas(found: any, doNotWant: any, ...[msg, extra]: [] | [string] | [{
        [k: string]: any;
    }] | [string, {
        [k: string]: any;
    }]): boolean;
    hasStrict(found: any, wanted: any, ...[msg, extra]: [] | [string] | [{
        [k: string]: any;
    }] | [string, {
        [k: string]: any;
    }]): boolean;
    notHasStrict(found: any, doNotWant: any, ...[msg, extra]: [] | [string] | [{
        [k: string]: any;
    }] | [string, {
        [k: string]: any;
    }]): boolean;
    match(found: any, wanted: any, ...[msg, extra]: [] | [string] | [{
        [k: string]: any;
    }] | [string, {
        [k: string]: any;
    }]): boolean;
    notMatch(found: any, doNotWant: any, ...[msg, extra]: [] | [string] | [{
        [k: string]: any;
    }] | [string, {
        [k: string]: any;
    }]): boolean;
    hasProp<T extends {}>(found: T, wanted: string | number | symbol, ...[msg, extra]: [] | [string] | [{
        [k: string]: any;
    }] | [string, {
        [k: string]: any;
    }]): boolean;
    hasOwnProp<T_1 extends {}>(found: T_1, wanted: string | number | symbol, ...[msg, extra]: [] | [string] | [{
        [k: string]: any;
    }] | [string, {
        [k: string]: any;
    }]): boolean;
    hasProps<T_2 extends {}>(found: T_2, wanted: Iterable<string | number | symbol>, ...[msg, extra]: [] | [string] | [{
        [k: string]: any;
    }] | [string, {
        [k: string]: any;
    }]): boolean;
    hasOwnProps<T_3 extends {}>(found: T_3, wanted: Iterable<string | number | symbol>, ...[msg, extra]: [] | [string] | [{
        [k: string]: any;
    }] | [string, {
        [k: string]: any;
    }]): boolean;
    throws(fn: Function | (() => any), ...[wanted, msg, extra]: [] | [wanted: RegExp | Error | ErrorConstructor | {
        [k: string]: any;
        message: string;
    }] | [RegExp | Error | ErrorConstructor | {
        [k: string]: any;
        message: string;
    }, string] | [RegExp | Error | ErrorConstructor | {
        [k: string]: any;
        message: string;
    }, {
        [k: string]: any;
    }] | [RegExp | Error | ErrorConstructor | {
        [k: string]: any;
        message: string;
    }, string, {
        [k: string]: any;
    }]): boolean | Error;
    doesNotThrow(fn: Function | (() => any), ...[msg, extra]: [] | [string] | [{
        [k: string]: any;
    }] | [string, {
        [k: string]: any;
    }]): boolean | Error;
    rejects<T_4 extends unknown = any>(fnOrPromise: (() => Promise<T_4>) | Promise<T_4>, ...[wanted, msg, extra]: [] | [wanted: RegExp | Error | ErrorConstructor | {
        [k: string]: any;
        message: string;
    }] | [RegExp | Error | ErrorConstructor | {
        [k: string]: any;
        message: string;
    }, string] | [RegExp | Error | ErrorConstructor | {
        [k: string]: any;
        message: string;
    }, {
        [k: string]: any;
    }] | [RegExp | Error | ErrorConstructor | {
        [k: string]: any;
        message: string;
    }, string, {
        [k: string]: any;
    }]): Promise<boolean | Error>;
    resolves<T_5 extends unknown = any>(fnOrPromise: Promise<T_5> | (() => Promise<T_5>), ...[msg, extra]: [] | [string] | [{
        [k: string]: any;
    }] | [string, {
        [k: string]: any;
    }]): Promise<boolean | Error>;
    resolveMatch<T_6 extends unknown = any>(fnOrPromise: Promise<T_6> | (() => Promise<T_6>), wanted: any, ...[msg, extra]: [] | [string] | [{
        [k: string]: any;
    }] | [string, {
        [k: string]: any;
    }]): Promise<boolean | Error>;
    emits(emitter: import("events") | EventTarget, event: string, ...[msg, extra]: [] | [string] | [{
        [k: string]: any;
    }] | [string, {
        [k: string]: any;
    }]): Promise<void>;
}, any>;
type SecondParam<T extends [any] | [any, any]> = T extends [any, any] ? T[1] : unknown;
export type Plugin_stdin_Opts = SecondParam<Parameters<typeof Plugin_stdin>>;
export type Plugin_spawn_Opts = SecondParam<Parameters<typeof Plugin_spawn>>;
export type Plugin_beforeEach_Opts = SecondParam<Parameters<typeof Plugin_beforeEach>>;
export type Plugin_afterEach_Opts = SecondParam<Parameters<typeof Plugin_afterEach>>;
export type Plugin_asserts_Opts = SecondParam<Parameters<typeof Plugin_asserts>>;
export type TestOpts = TestBaseOpts & Plugin_stdin_Opts & Plugin_spawn_Opts & Plugin_beforeEach_Opts & Plugin_afterEach_Opts & Plugin_asserts_Opts;
type TTest = TestBase & ReturnType<typeof Plugin_stdin> & ReturnType<typeof Plugin_spawn> & ReturnType<typeof Plugin_beforeEach> & ReturnType<typeof Plugin_afterEach> & ReturnType<typeof Plugin_asserts>;
export interface Test extends TTest {
    end(): this;
    t: this;
    test(name: string, extra: {
        [k: string]: any;
    }, cb?: (t: Test) => any): Promise<FinalResults | null>;
    test(name: string, cb?: (t: Test) => any): Promise<FinalResults | null>;
    test(extra: {
        [k: string]: any;
    }, cb?: (t: Test) => any): Promise<FinalResults | null>;
    test(cb?: (t: Test) => any): Promise<FinalResults | null>;
    test(...args: TestArgs<Test>): Promise<FinalResults | null>;
    todo(name: string, extra: {
        [k: string]: any;
    }, cb?: (t: Test) => any): Promise<FinalResults | null>;
    todo(name: string, cb?: (t: Test) => any): Promise<FinalResults | null>;
    todo(extra: {
        [k: string]: any;
    }, cb?: (t: Test) => any): Promise<FinalResults | null>;
    todo(cb?: (t: Test) => any): Promise<FinalResults | null>;
    todo(...args: TestArgs<Test>): Promise<FinalResults | null>;
    skip(name: string, extra: {
        [k: string]: any;
    }, cb?: (t: Test) => any): Promise<FinalResults | null>;
    skip(name: string, cb?: (t: Test) => any): Promise<FinalResults | null>;
    skip(extra: {
        [k: string]: any;
    }, cb?: (t: Test) => any): Promise<FinalResults | null>;
    skip(cb?: (t: Test) => any): Promise<FinalResults | null>;
    skip(...args: TestArgs<Test>): Promise<FinalResults | null>;
}
export declare class Test extends TestBase {
    constructor(opts: TestOpts);
    test(name: string, extra: {
        [k: string]: any;
    }, cb?: (t: Test) => any): Promise<FinalResults | null>;
    test(name: string, cb?: (t: Test) => any): Promise<FinalResults | null>;
    test(extra: {
        [k: string]: any;
    }, cb?: (t: Test) => any): Promise<FinalResults | null>;
    test(cb?: (t: Test) => any): Promise<FinalResults | null>;
    todo(name: string, extra: {
        [k: string]: any;
    }, cb?: (t: Test) => any): Promise<FinalResults | null>;
    todo(name: string, cb?: (t: Test) => any): Promise<FinalResults | null>;
    todo(extra: {
        [k: string]: any;
    }, cb?: (t: Test) => any): Promise<FinalResults | null>;
    todo(cb?: (t: Test) => any): Promise<FinalResults | null>;
    skip(name: string, extra: {
        [k: string]: any;
    }, cb?: (t: Test) => any): Promise<FinalResults | null>;
    skip(name: string, cb?: (t: Test) => any): Promise<FinalResults | null>;
    skip(extra: {
        [k: string]: any;
    }, cb?: (t: Test) => any): Promise<FinalResults | null>;
    skip(cb?: (t: Test) => any): Promise<FinalResults | null>;
}
export {};
//# sourceMappingURL=index.d.ts.map