import { TestArgs, TestBase, TestBaseOpts } from '@tapjs/core';
import { FinalResults } from 'tap-parser';
export declare const Plugin_stdin: (t: TestBase) => {
    "__#4@#private": any;
    stdin(name: string, extra?: import("@tapjs/core").StdinOpts | undefined): Promise<FinalResults | null>;
    stdin(extra?: import("@tapjs/core").StdinOpts | undefined): Promise<FinalResults | null>;
};
export declare const Plugin_spawn: (t: TestBase) => {
    "__#5@#private": any;
    spawn(cmd: string): Promise<FinalResults | null>;
    spawn(cmd: string, options: import("@tapjs/core/plugin/spawn").SpawnOpts, name?: string | undefined): Promise<FinalResults | null>;
    spawn(cmd: string, args: string | string[], name?: string | undefined): Promise<FinalResults | null>;
    spawn(cmd: string, args: string | string[], options: import("@tapjs/core/plugin/spawn").SpawnOpts, name?: string | undefined): Promise<FinalResults | null>;
};
export declare const Plugin_beforeEach: (t: TestBase) => {
    "__#6@#private": any;
    beforeEach(fn: (t: Test) => void | Promise<void>): void;
};
export declare const Plugin_afterEach: (t: TestBase) => {
    "__#7@#private": any;
    afterEach(fn: (t: Test) => void | Promise<void>): void;
};
export declare const Plugin_asserts: (t: TestBase) => import("@tapjs/asserts").Assertions;
export declare const Plugin_snapshot: (t: TestBase, opts: import("@tapjs/snapshot").SnapshotOptions) => import("@tapjs/snapshot").SnapshotPlugin;
type PI<O extends TestBaseOpts | any = any> = ((t: TestBase, opts: O) => Plug) | ((t: TestBase) => Plug);
export declare const pluginsLoaded: Map<string, PI<any>>;
type Plug = TestBase | {
    t: Test;
} | ReturnType<typeof Plugin_stdin> | ReturnType<typeof Plugin_spawn> | ReturnType<typeof Plugin_beforeEach> | ReturnType<typeof Plugin_afterEach> | ReturnType<typeof Plugin_asserts> | ReturnType<typeof Plugin_snapshot>;
type SecondParam<T extends [any] | [any, any]> = T extends [any, any] ? T[1] : unknown;
export type Plugin_stdin_Opts = SecondParam<Parameters<typeof Plugin_stdin>>;
export type Plugin_spawn_Opts = SecondParam<Parameters<typeof Plugin_spawn>>;
export type Plugin_beforeEach_Opts = SecondParam<Parameters<typeof Plugin_beforeEach>>;
export type Plugin_afterEach_Opts = SecondParam<Parameters<typeof Plugin_afterEach>>;
export type Plugin_asserts_Opts = SecondParam<Parameters<typeof Plugin_asserts>>;
export type Plugin_snapshot_Opts = SecondParam<Parameters<typeof Plugin_snapshot>>;
export type TestOpts = TestBaseOpts & Plugin_stdin_Opts & Plugin_spawn_Opts & Plugin_beforeEach_Opts & Plugin_afterEach_Opts & Plugin_asserts_Opts & Plugin_snapshot_Opts;
type TTest = TestBase & ReturnType<typeof Plugin_stdin> & ReturnType<typeof Plugin_spawn> & ReturnType<typeof Plugin_beforeEach> & ReturnType<typeof Plugin_afterEach> & ReturnType<typeof Plugin_asserts> & ReturnType<typeof Plugin_snapshot>;
export interface Test extends TTest {
    end(): this;
    t: this;
    test(name: string, extra: {
        [k: string]: any;
    }, cb?: (t: Test) => any): Promise<FinalResults | null>;
    test(name: string, cb?: (t: Test) => any): Promise<FinalResults | null>;
    test(extra: {
        [k: string]: any;
    }, cb?: (t: Test) => any): Promise<FinalResults | null>;
    test(cb?: (t: Test) => any): Promise<FinalResults | null>;
    test(...args: TestArgs<Test>): Promise<FinalResults | null>;
    todo(name: string, extra: {
        [k: string]: any;
    }, cb?: (t: Test) => any): Promise<FinalResults | null>;
    todo(name: string, cb?: (t: Test) => any): Promise<FinalResults | null>;
    todo(extra: {
        [k: string]: any;
    }, cb?: (t: Test) => any): Promise<FinalResults | null>;
    todo(cb?: (t: Test) => any): Promise<FinalResults | null>;
    todo(...args: TestArgs<Test>): Promise<FinalResults | null>;
    skip(name: string, extra: {
        [k: string]: any;
    }, cb?: (t: Test) => any): Promise<FinalResults | null>;
    skip(name: string, cb?: (t: Test) => any): Promise<FinalResults | null>;
    skip(extra: {
        [k: string]: any;
    }, cb?: (t: Test) => any): Promise<FinalResults | null>;
    skip(cb?: (t: Test) => any): Promise<FinalResults | null>;
    skip(...args: TestArgs<Test>): Promise<FinalResults | null>;
}
export declare class Test extends TestBase {
    constructor(opts: TestOpts);
    static get plugins(): Map<string, PI<any>>;
    static pluginLoaded(plugin: (t: TestBase, opts?: any) => any): boolean;
    test(name: string, extra: {
        [k: string]: any;
    }, cb?: (t: Test) => any): Promise<FinalResults | null>;
    test(name: string, cb?: (t: Test) => any): Promise<FinalResults | null>;
    test(extra: {
        [k: string]: any;
    }, cb?: (t: Test) => any): Promise<FinalResults | null>;
    test(cb?: (t: Test) => any): Promise<FinalResults | null>;
    todo(name: string, extra: {
        [k: string]: any;
    }, cb?: (t: Test) => any): Promise<FinalResults | null>;
    todo(name: string, cb?: (t: Test) => any): Promise<FinalResults | null>;
    todo(extra: {
        [k: string]: any;
    }, cb?: (t: Test) => any): Promise<FinalResults | null>;
    todo(cb?: (t: Test) => any): Promise<FinalResults | null>;
    skip(name: string, extra: {
        [k: string]: any;
    }, cb?: (t: Test) => any): Promise<FinalResults | null>;
    skip(name: string, cb?: (t: Test) => any): Promise<FinalResults | null>;
    skip(extra: {
        [k: string]: any;
    }, cb?: (t: Test) => any): Promise<FinalResults | null>;
    skip(cb?: (t: Test) => any): Promise<FinalResults | null>;
}
export {};
//# sourceMappingURL=index.d.ts.map