// This file is automatically generated, please do not edit

import { FinalResults } from 'tap-parser'
import {
  parseTestArgs,
  TestBase, TestBaseOpts,
  TestArgs,
} from '@tapjs/core'

const copyToString = (v: Function) => ({
  toString: Object.assign(() => v.toString(), {
    toString: () => 'function toString() { [native code] }',
  }),
})

import Plugin_stdin_0 from "@tapjs/core/plugin/stdin.js"
import Plugin_spawn_1 from "@tapjs/core/plugin/spawn.js"
import Plugin_beforeEach_2 from "@tapjs/core/plugin/before-each.js"
import Plugin_afterEach_3 from "@tapjs/core/plugin/after-each.js"

type PI<O extends TestBaseOpts | any = any> =
  | ((t: Test, opts: O) => Plug)
  | ((t: Test) => Plug)

const plugins: PI[] = [
  Plugin_stdin_0,
  Plugin_spawn_1,
  Plugin_beforeEach_2,
  Plugin_afterEach_3,
]
type Plug =
  | TestBase
  | { t: Test }
  | ReturnType<typeof Plugin_stdin_0>
  | ReturnType<typeof Plugin_spawn_1>
  | ReturnType<typeof Plugin_beforeEach_2>
  | ReturnType<typeof Plugin_afterEach_3>

type PlugKeys =
  | keyof TestBase
  | 't'
  | keyof ReturnType<typeof Plugin_stdin_0>
  | keyof ReturnType<typeof Plugin_spawn_1>
  | keyof ReturnType<typeof Plugin_beforeEach_2>
  | keyof ReturnType<typeof Plugin_afterEach_3>

type SecondParam<
  T extends [any] | [any, any],
  Fallback extends unknown = unknown
> = T extends [any, any] ? T[1] : Fallback

type Plugin_stdin_0_Opts = SecondParam<
  Parameters<typeof Plugin_stdin_0>,
  TestBaseOpts
>
type Plugin_spawn_1_Opts = SecondParam<
  Parameters<typeof Plugin_spawn_1>,
  TestBaseOpts
>
type Plugin_beforeEach_2_Opts = SecondParam<
  Parameters<typeof Plugin_beforeEach_2>,
  TestBaseOpts
>
type Plugin_afterEach_3_Opts = SecondParam<
  Parameters<typeof Plugin_afterEach_3>,
  TestBaseOpts
>

type TestOpts = TestBaseOpts
  & Plugin_stdin_0_Opts
  & Plugin_spawn_1_Opts
  & Plugin_beforeEach_2_Opts
  & Plugin_afterEach_3_Opts

type TTest = TestBase
  & ReturnType<typeof Plugin_stdin_0>
  & ReturnType<typeof Plugin_spawn_1>
  & ReturnType<typeof Plugin_beforeEach_2>
  & ReturnType<typeof Plugin_afterEach_3>


export interface Test extends TTest {
  end(): this
  t: Test
  test(
    name: string,
    extra: { [k: string]: any },
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  test(
    name: string,
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  test(
    extra: { [k: string]: any },
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  test(cb?: (t: Test) => any): Promise<FinalResults | null>
  test(
    ...args: TestArgs<Test>
  ): Promise<FinalResults | null>

  todo(
    name: string,
    extra: { [k: string]: any },
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  todo(
    name: string,
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  todo(
    extra: { [k: string]: any },
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  todo(cb?: (t: Test) => any): Promise<FinalResults | null>
  todo(
    ...args: TestArgs<Test>
  ): Promise<FinalResults | null>

  skip(
    name: string,
    extra: { [k: string]: any },
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  skip(
    name: string,
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  skip(
    extra: { [k: string]: any },
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  skip(cb?: (t: Test) => any): Promise<FinalResults | null>
  skip(
    ...args: TestArgs<Test>
  ): Promise<FinalResults | null>
}

const applyPlugins = (base: Test): Test => {
  const ext: Plug[] = [
    ...plugins.map(p => p(base, base.options)),
    base,
  ]
  const getCache = new Map<any, any>()
  const t = new Proxy(base, {
    has(_, p) {
      for (const t of ext) {
        if (Reflect.has(t, p)) return true
      }
      return false
    },
    ownKeys() {
      const k: PlugKeys[] = []
      for (const t of ext) {
        const keys = Reflect.ownKeys(t) as PlugKeys[]
        k.push(...keys)
      }
      return [...new Set(k)]
    },
    getOwnPropertyDescriptor(_, p) {
      for (const t of ext) {
        const prop = Reflect.getOwnPropertyDescriptor(t, p)
        if (prop) return prop
      }
      return undefined
    },
    set(_, p, v) {
      // check to see if there's any setters, and if so, set it there
      // otherwise, just set on the base
      for (const t of ext) {
        let o: Object | null = t
        while (o) {
          if (Reflect.getOwnPropertyDescriptor(o, p)?.set) {
            //@ts-ignore
            t[p] = v
            return true
          }
          o = Reflect.getPrototypeOf(o)
        }
      }
      //@ts-ignore
      base[p as keyof TestBase] = v
      return true
    },
    get(_, p) {
      // cache get results so t.blah === t.blah
      // we only cache functions, so that getters aren't memoized
      // Of course, a getter that returns a function will be broken,
      // at least when accessed from outside the plugin, but that's
      // a pretty narrow caveat, and easily documented.
      if (getCache.has(p)) return getCache.get(p)
      for (const plug of ext) {
        if (p in plug) {
          //@ts-ignore
          const v = plug[p]
          // Functions need special handling so that they report
          // the correct toString and are called on the correct object
          // Otherwise attempting to access #private props will fail.
          if (typeof v === 'function') {
            const f: (this: Plug, ...args: any) => any =
              function (...args: any[]) {
                const thisArg = this === t ? plug : this
                return v.apply(thisArg, args)
              }
            const vv = Object.assign(f, copyToString(v))
            const nameProp =
              Reflect.getOwnPropertyDescriptor(v, 'name')
            if (nameProp) {
              Reflect.defineProperty(f, 'name', nameProp)
            }
            getCache.set(p, vv)
            return vv
          } else {
            getCache.set(p, v)
            return v
          }
        }
      }
    },
  })
  Object.assign(base, { t })
  ext.unshift({ t })
  return t
}

export class Test extends TestBase {
  constructor(opts: TestOpts) {
    super(opts)
    return applyPlugins(this)
  }

  test(
    name: string,
    extra: { [k: string]: any },
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  test(
    name: string,
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  test(
    extra: { [k: string]: any },
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  test(cb?: (t: Test) => any): Promise<FinalResults | null>
  test(
    ...args: TestArgs<Test>
  ): Promise<FinalResults | null> {
    const extra = parseTestArgs(...args)
    extra.todo = true
    return this.sub(Test, extra, this.test)
  }

  todo(
    name: string,
    extra: { [k: string]: any },
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  todo(
    name: string,
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  todo(
    extra: { [k: string]: any },
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  todo(cb?: (t: Test) => any): Promise<FinalResults | null>
  todo(
    ...args: TestArgs<Test>
  ): Promise<FinalResults | null> {
    const extra = parseTestArgs(...args)
    extra.todo = true
    return this.sub(Test, extra, this.todo)
  }

  skip(
    name: string,
    extra: { [k: string]: any },
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  skip(
    name: string,
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  skip(
    extra: { [k: string]: any },
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  skip(cb?: (t: Test) => any): Promise<FinalResults | null>
  skip(
    ...args: TestArgs<Test>
  ): Promise<FinalResults | null> {
    const extra = parseTestArgs(...args)
    extra.skip = true
    return this.sub(Test, extra, this.skip)
  }
}
