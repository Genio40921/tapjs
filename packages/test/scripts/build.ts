#!/usr/bin/env node --loader=ts-node/esm --no-warnings

import { globSync } from 'glob'
import { mkdirp } from 'mkdirp'
import { spawnSync } from 'node:child_process'
import { readFileSync, writeFileSync } from 'node:fs'
import { basename, resolve } from 'node:path'

if (typeof process.argv[2] !== 'string') {
  console.error('usage: build.ts [...plugins]')
  process.exit(1)
}

const templateFile = resolve(
  __dirname,
  './test-template.ts'
)
let template = readFileSync(templateFile, 'utf8')

const dir = resolve(
  __dirname,
  '../node_modules/@tapjs/.test-built'
)
mkdirp.sync(resolve(dir, 'src'))
const out = resolve(dir, 'src/index.ts')

const copies = globSync(
  ['tsconfig*.json', 'fixup.sh', 'package-template.json'],
  { cwd: __dirname, absolute: true }
)
for (const f of copies) {
  const b = basename(f)
  const t =
    b === 'package-template.json' ? 'package.json' : b
  writeFileSync(resolve(dir, t), readFileSync(f))
}

const plugins = process.argv.slice(2)
const pluginNames = plugins.map(
  (p, i) =>
    'Plugin_' +
    basename(p)
      .replace(/\.([cm]?[jt]sx?)$/, '')
      .replace(/[-_.]+(.)/g, (_, $1) => $1.toUpperCase())
      .replace(/[^a-zA-Z0-9]+/g, ' ')
      .trim()
      .replace(' ', '_') +
    '_' +
    i
)

const pluginImport = plugins
  .map(
    (p, i) =>
      `import ${pluginNames[i]} from ${JSON.stringify(p)}\n`
  )
  .join('')

const pluginsCode = `const plugins: PI[] = [
${plugins.map((_, i) => `  ${pluginNames[i]},\n`).join('')}]
type Plug =
  | TestBase
  | { t: Test }
${plugins
  .map(
    (_, i) => `  | ReturnType<typeof ${pluginNames[i]}>\n`
  )
  .join('')}
type PlugKeys =
  | keyof TestBase
  | 't'
${plugins
  .map(
    (_, i) =>
      `  | keyof ReturnType<typeof ${pluginNames[i]}>\n`
  )
  .join('')}`

const opts = `type SecondParam<
  T extends [any] | [any, any],
  Fallback extends unknown = unknown
> = T extends [any, any] ? T[1] : Fallback

${plugins
  .map(
    (_, i) => `type ${pluginNames[i]}_Opts = SecondParam<
  Parameters<typeof ${pluginNames[i]}>,
  TestBaseOpts
>\n`
  )
  .join('')}
type TestOpts = TestBaseOpts${plugins
  .map((_, i) => `\n  & ${pluginNames[i]}_Opts`)
  .join('')}
`

const testInterface = `type TTest = TestBase
${plugins
  .map(
    (_, i) => `  & ReturnType<typeof ${pluginNames[i]}>\n`
  )
  .join('')}
`

const swapTag = (
  src: string,
  tag: string,
  code: string
): string => {
  const st = '//{{' + tag + ' START}}\n'
  const et = '//{{' + tag + ' END}}\n'
  const start = src.indexOf(st)
  const end = src.indexOf(et)
  return (
    src.substring(0, start) +
    code +
    src.substring(end + et.length)
  )
}

const swapTags = (
  src: string,
  tags: { [k: string]: string }
): string => {
  let res = src
  for (const [tag, code] of Object.entries(tags)) {
    res = swapTag(res, tag, code)
  }
  return res
}

writeFileSync(
  out,
  swapTags(template, {
    'HEADER COMMENT': `// This file is automatically generated, please do not edit\n`,
    'PLUGIN IMPORT': pluginImport,
    'PLUGINS CODE': pluginsCode,
    OPTS: opts,
    'TEST INTERFACE': testInterface,
  })
)

spawnSync('npm', ['run', 'prepare'], {
  cwd: dir,
  stdio: 'inherit',
})

export {}
