// This file is automatically generated, please do not edit

import {
  parseTestArgs,
  TestArgs,
  TestBase,
  TestBaseOpts,
} from '@tapjs/core'
import { FinalResults } from 'tap-parser'

import type { ConfigSet, Jack } from 'jackspeak'
import { isConfigOption } from 'jackspeak'

const copyToString = (v: Function) => ({
  toString: Object.assign(() => v.toString(), {
    toString: () => 'function toString() { [native code] }',
  }),
})
const copyFunction = (t: Test, plug: Plug, v: Function) => {
  const f: (this: Plug, ...args: any) => any = function (
    ...args: any[]
  ) {
    const thisArg = this === t ? plug : this
    return v.apply(thisArg, args)
  }
  const vv = Object.assign(f, copyToString(v))
  const nameProp = Reflect.getOwnPropertyDescriptor(
    v,
    'name'
  )
  if (nameProp) {
    Reflect.defineProperty(f, 'name', nameProp)
  }
  return vv
}

import * as _Plugin_asserts from "@tapjs/asserts"
import * as _Plugin_after from "@tapjs/core/plugin/after"
import * as _Plugin_afterEach from "@tapjs/core/plugin/after-each"
import * as _Plugin_before from "@tapjs/core/plugin/before"
import * as _Plugin_beforeEach from "@tapjs/core/plugin/before-each"
import * as _Plugin_spawn from "@tapjs/core/plugin/spawn"
import * as _Plugin_stdin from "@tapjs/core/plugin/stdin"
import * as _Plugin_typescript from "@tapjs/core/plugin/typescript"
import * as _Plugin_filter from "@tapjs/filter"
import * as _Plugin_fixture from "@tapjs/fixture"
import * as _Plugin_intercept from "@tapjs/intercept"
import * as _Plugin_mock from "@tapjs/mock"
import * as _Plugin_snapshot from "@tapjs/snapshot"
export const Plugin_asserts = _Plugin_asserts.plugin
export const Plugin_after = _Plugin_after.plugin
export const Plugin_afterEach = _Plugin_afterEach.plugin
export const Plugin_before = _Plugin_before.plugin
export const Plugin_beforeEach = _Plugin_beforeEach.plugin
export const Plugin_spawn = _Plugin_spawn.plugin
export const Plugin_stdin = _Plugin_stdin.plugin
export const Plugin_filter = _Plugin_filter.plugin
export const Plugin_fixture = _Plugin_fixture.plugin
export const Plugin_intercept = _Plugin_intercept.plugin
export const Plugin_mock = _Plugin_mock.plugin
export const Plugin_snapshot = _Plugin_snapshot.plugin

type PI<O extends TestBaseOpts | any = any> =
  | ((t: TestBase, opts: O) => Plug)
  | ((t: TestBase) => Plug)

const plugins: PI[] = [
  Plugin_asserts,
  Plugin_after,
  Plugin_afterEach,
  Plugin_before,
  Plugin_beforeEach,
  Plugin_spawn,
  Plugin_stdin,
  Plugin_filter,
  Plugin_fixture,
  Plugin_intercept,
  Plugin_mock,
  Plugin_snapshot,
]
export const pluginsLoaded = new Map<string, PI>([
  ['asserts', Plugin_asserts],
  ['after', Plugin_after],
  ['afterEach', Plugin_afterEach],
  ['before', Plugin_before],
  ['beforeEach', Plugin_beforeEach],
  ['spawn', Plugin_spawn],
  ['stdin', Plugin_stdin],
  ['filter', Plugin_filter],
  ['fixture', Plugin_fixture],
  ['intercept', Plugin_intercept],
  ['mock', Plugin_mock],
  ['snapshot', Plugin_snapshot],
])

type Plug =
  | TestBase
  | { t: Test }
  | ReturnType<typeof Plugin_asserts>
  | ReturnType<typeof Plugin_after>
  | ReturnType<typeof Plugin_afterEach>
  | ReturnType<typeof Plugin_before>
  | ReturnType<typeof Plugin_beforeEach>
  | ReturnType<typeof Plugin_spawn>
  | ReturnType<typeof Plugin_stdin>
  | ReturnType<typeof Plugin_filter>
  | ReturnType<typeof Plugin_fixture>
  | ReturnType<typeof Plugin_intercept>
  | ReturnType<typeof Plugin_mock>
  | ReturnType<typeof Plugin_snapshot>

type PlugKeys =
  | keyof TestBase
  | 't'
  | keyof ReturnType<typeof Plugin_asserts>
  | keyof ReturnType<typeof Plugin_after>
  | keyof ReturnType<typeof Plugin_afterEach>
  | keyof ReturnType<typeof Plugin_before>
  | keyof ReturnType<typeof Plugin_beforeEach>
  | keyof ReturnType<typeof Plugin_spawn>
  | keyof ReturnType<typeof Plugin_stdin>
  | keyof ReturnType<typeof Plugin_filter>
  | keyof ReturnType<typeof Plugin_fixture>
  | keyof ReturnType<typeof Plugin_intercept>
  | keyof ReturnType<typeof Plugin_mock>
  | keyof ReturnType<typeof Plugin_snapshot>

export const config = <C extends ConfigSet>(jack: Jack<C>) => {
  const config_0 = _Plugin_filter.config["only"]
  if (!isConfigOption(config_0, "boolean", false)) {
    throw new Error("Invalid config option \"only\" defined in plugin: @tapjs/filter")
  }
  const config_1 = _Plugin_filter.config["grep"]
  if (!isConfigOption(config_1, "string", true)) {
    throw new Error("Invalid config option \"grep\" defined in plugin: @tapjs/filter")
  }
  const config_2 = _Plugin_filter.config["invert"]
  if (!isConfigOption(config_2, "boolean", false)) {
    throw new Error("Invalid config option \"invert\" defined in plugin: @tapjs/filter")
  }
  const config_3 = _Plugin_filter.config["no-invert"]
  if (!isConfigOption(config_3, "boolean", false)) {
    throw new Error("Invalid config option \"no-invert\" defined in plugin: @tapjs/filter")
  }
  const config_4 = _Plugin_fixture.config["save-fixture"]
  if (!isConfigOption(config_4, "boolean", false)) {
    throw new Error("Invalid config option \"save-fixture\" defined in plugin: @tapjs/fixture")
  }
  const config_5 = _Plugin_snapshot.config["snapshot"]
  if (!isConfigOption(config_5, "boolean", false)) {
    throw new Error("Invalid config option \"snapshot\" defined in plugin: @tapjs/snapshot")
  }
  return jack
    .heading("From plugin: @tapjs/filter")
    .flag({["only"]: config_0})
    .optList({["grep"]: config_1})
    .flag({["invert"]: config_2})
    .flag({["no-invert"]: config_3})
    .heading("From plugin: @tapjs/fixture")
    .flag({["save-fixture"]: config_4})
    .heading("From plugin: @tapjs/snapshot")
    .flag({["snapshot"]: config_5})
}

export const loaders = [
  "ts-node/esm",
  "@tapjs/mock/loader"
]

export const signature = "@tapjs/asserts\n@tapjs/core/plugin/after\n@tapjs/core/plugin/after-each\n@tapjs/core/plugin/before\n@tapjs/core/plugin/before-each\n@tapjs/core/plugin/spawn\n@tapjs/core/plugin/stdin\n@tapjs/core/plugin/typescript\n@tapjs/filter\n@tapjs/fixture\n@tapjs/intercept\n@tapjs/mock\n@tapjs/snapshot"

type SecondParam<
  T extends [any] | [any, any],
> = T extends [any, any] ? T[1] : unknown

export type Plugin_asserts_Opts = SecondParam<
  Parameters<typeof Plugin_asserts>
>
export type Plugin_after_Opts = SecondParam<
  Parameters<typeof Plugin_after>
>
export type Plugin_afterEach_Opts = SecondParam<
  Parameters<typeof Plugin_afterEach>
>
export type Plugin_before_Opts = SecondParam<
  Parameters<typeof Plugin_before>
>
export type Plugin_beforeEach_Opts = SecondParam<
  Parameters<typeof Plugin_beforeEach>
>
export type Plugin_spawn_Opts = SecondParam<
  Parameters<typeof Plugin_spawn>
>
export type Plugin_stdin_Opts = SecondParam<
  Parameters<typeof Plugin_stdin>
>
export type Plugin_filter_Opts = SecondParam<
  Parameters<typeof Plugin_filter>
>
export type Plugin_fixture_Opts = SecondParam<
  Parameters<typeof Plugin_fixture>
>
export type Plugin_intercept_Opts = SecondParam<
  Parameters<typeof Plugin_intercept>
>
export type Plugin_mock_Opts = SecondParam<
  Parameters<typeof Plugin_mock>
>
export type Plugin_snapshot_Opts = SecondParam<
  Parameters<typeof Plugin_snapshot>
>

export type TestOpts = TestBaseOpts
  & Plugin_asserts_Opts
  & Plugin_after_Opts
  & Plugin_afterEach_Opts
  & Plugin_before_Opts
  & Plugin_beforeEach_Opts
  & Plugin_spawn_Opts
  & Plugin_stdin_Opts
  & Plugin_filter_Opts
  & Plugin_fixture_Opts
  & Plugin_intercept_Opts
  & Plugin_mock_Opts
  & Plugin_snapshot_Opts

type TTest = TestBase
  & ReturnType<typeof Plugin_asserts>
  & ReturnType<typeof Plugin_after>
  & ReturnType<typeof Plugin_afterEach>
  & ReturnType<typeof Plugin_before>
  & ReturnType<typeof Plugin_beforeEach>
  & ReturnType<typeof Plugin_spawn>
  & ReturnType<typeof Plugin_stdin>
  & ReturnType<typeof Plugin_filter>
  & ReturnType<typeof Plugin_fixture>
  & ReturnType<typeof Plugin_intercept>
  & ReturnType<typeof Plugin_mock>
  & ReturnType<typeof Plugin_snapshot>


export interface Test extends TTest {
  end(): this
  test(
    name: string,
    extra: TestOpts,
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  test(
    name: string,
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  test(
    extra: TestOpts,
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  test(cb?: (t: Test) => any): Promise<FinalResults | null>
  test(
    ...args: TestArgs<Test>
  ): Promise<FinalResults | null>

  todo(
    name: string,
    extra: TestOpts,
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  todo(
    name: string,
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  todo(
    extra: TestOpts,
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  todo(cb?: (t: Test) => any): Promise<FinalResults | null>
  todo(
    ...args: TestArgs<Test>
  ): Promise<FinalResults | null>

  skip(
    name: string,
    extra: TestOpts,
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  skip(
    name: string,
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  skip(
    extra: TestOpts,
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  skip(cb?: (t: Test) => any): Promise<FinalResults | null>
  skip(
    ...args: TestArgs<Test>
  ): Promise<FinalResults | null>
}

const applyPlugins = (
  base: Test,
  ext: Plug[] = [
    ...plugins.map(p => p(base, base.options)),
    base,
  ]
): Test => {
  const getCache = new Map<any, any>()
  // extend the proxy with Object.create, and then set the toStringTag
  // to 'Test', so we don't get stack frames like `Proxy.<anonymous>`
  const t = Object.create(
    new Proxy(base, {
      has(_, p) {
        for (const t of ext) {
          if (Reflect.has(t, p)) return true
        }
        return false
      },
      ownKeys() {
        const k: PlugKeys[] = []
        for (const t of ext) {
          const keys = Reflect.ownKeys(t) as PlugKeys[]
          k.push(...keys)
        }
        return [...new Set(k)]
      },
      getOwnPropertyDescriptor(_, p) {
        for (const t of ext) {
          const prop = Reflect.getOwnPropertyDescriptor(
            t,
            p
          )
          if (prop) return prop
        }
        return undefined
      },
      set(_, p, v) {
        // check to see if there's any setters, and if so, set it there
        // otherwise, just set on the base
        let didSet = false
        for (const t of ext) {
          let o: Object | null = t
          while (o) {
            // assign to the all plugs that can receive it
            const prop = Reflect.getOwnPropertyDescriptor(
              o,
              p
            )
            if (prop) {
              if (prop.set || prop.writable) {
                //@ts-ignore
                t[p] = v
                didSet = true
              }
              break
            }
            o = Reflect.getPrototypeOf(o)
          }
        }
        if (!didSet) {
          // if nothing has that field, assign to the base
          //@ts-ignore
          base[p] = v
        }
        return true
      },
      get(_, p) {
        if (p === Symbol.toStringTag) return 'Test'
        if (p === 'parent') {
          return base.parent?.t
        }
        // cache get results so t.blah === t.blah
        // we only cache functions, so that getters aren't memoized
        // Of course, a getter that returns a function will be broken,
        // at least when accessed from outside the plugin, but that's
        // a pretty narrow caveat, and easily documented.
        if (getCache.has(p)) return getCache.get(p)
        for (const plug of ext) {
          if (p in plug) {
            //@ts-ignore
            const v = plug[p]
            // Functions need special handling so that they report
            // the correct toString and are called on the correct object
            // Otherwise attempting to access #private props will fail.
            if (typeof v === 'function') {
              const vv = copyFunction(t, plug, v)
              getCache.set(p, vv)
              return vv
            } else if (p === 'parent') {
              return v?.t
            } else {
              return v
            }
          }
        }
      },
    })
  )
  Object.defineProperty(t, Symbol.toStringTag, {
    value: 'Test',
  })
  Object.assign(base, { t })
  ext.unshift({ t })
  return t
}

export class Test extends TestBase {
  constructor(opts: TestOpts) {
    super(opts)
    return applyPlugins(this)
  }

  static get plugins() {
    return pluginsLoaded
  }

  static pluginLoaded(
    plugin: (t: TestBase, opts?: any) => any
  ): boolean {
    return plugins.includes(plugin)
  }

  pluginLoaded<T extends any = any>(
    plugin: (t: TestBase, opts?: any) => T
  ): this is TestBase & T {
    return Test.pluginLoaded(plugin)
  }

  get plugins() {
    return Test.plugins
  }

  test(
    name: string,
    extra: TestOpts,
    cb: (t: Test) => any
  ): Promise<FinalResults | null>
  test(
    name: string,
    cb: (t: Test) => any
  ): Promise<FinalResults | null>
  test(
    extra: TestOpts,
    cb: (t: Test) => any
  ): Promise<FinalResults | null>
  test(cb: (t: Test) => any): Promise<FinalResults | null>
  test(
    ...args: TestArgs<Test>
  ): Promise<FinalResults | null> {
    const extra = parseTestArgs(...args)
    return this.sub(Test, extra, this.test)
  }

  todo(
    name: string,
    extra: TestOpts,
    cb: (t: Test) => any
  ): Promise<FinalResults | null>
  todo(
    name: string,
    cb: (t: Test) => any
  ): Promise<FinalResults | null>
  todo(
    extra: TestOpts,
    cb: (t: Test) => any
  ): Promise<FinalResults | null>
  todo(cb: (t: Test) => any): Promise<FinalResults | null>
  todo(
    ...args: TestArgs<Test>
  ): Promise<FinalResults | null> {
    const extra = parseTestArgs(...args)
    extra.todo = true
    return this.sub(Test, extra, this.todo)
  }

  skip(
    name: string,
    extra: TestOpts,
    cb: (t: Test) => any
  ): Promise<FinalResults | null>
  skip(
    name: string,
    cb: (t: Test) => any
  ): Promise<FinalResults | null>
  skip(
    extra: TestOpts,
    cb: (t: Test) => any
  ): Promise<FinalResults | null>
  skip(cb: (t: Test) => any): Promise<FinalResults | null>
  skip(
    ...args: TestArgs<Test>
  ): Promise<FinalResults | null> {
    const extra = parseTestArgs(...args)
    extra.skip = true
    return this.sub(Test, extra, this.skip)
  }
}
