// This file is automatically generated, please do not edit

import {
  parseTestArgs,
  TestArgs,
  TestBase,
  TestBaseOpts,
} from '@tapjs/core'
import { FinalResults } from 'tap-parser'

const copyToString = (v: Function) => ({
  toString: Object.assign(() => v.toString(), {
    toString: () => 'function toString() { [native code] }',
  }),
})
const copyFunction = (t: Test, plug: Plug, v: Function) => {
  const f: (this: Plug, ...args: any) => any = function (
    ...args: any[]
  ) {
    const thisArg = this === t ? plug : this
    return v.apply(thisArg, args)
  }
  const vv = Object.assign(f, copyToString(v))
  const nameProp = Reflect.getOwnPropertyDescriptor(
    v,
    'name'
  )
  if (nameProp) {
    Reflect.defineProperty(f, 'name', nameProp)
  }
  return vv
}

import _Plugin_stdin from "@tapjs/core/plugin/stdin"
import _Plugin_spawn from "@tapjs/core/plugin/spawn"
import _Plugin_before from "@tapjs/core/plugin/before"
import _Plugin_beforeEach from "@tapjs/core/plugin/before-each"
import _Plugin_after from "@tapjs/core/plugin/after"
import _Plugin_afterEach from "@tapjs/core/plugin/after-each"
import _Plugin_asserts from "@tapjs/asserts"
import _Plugin_snapshot from "@tapjs/snapshot"
import _Plugin_fixture from "@tapjs/fixture"
import _Plugin_mock from "@tapjs/mock"
export const Plugin_stdin = _Plugin_stdin
export const Plugin_spawn = _Plugin_spawn
export const Plugin_before = _Plugin_before
export const Plugin_beforeEach = _Plugin_beforeEach
export const Plugin_after = _Plugin_after
export const Plugin_afterEach = _Plugin_afterEach
export const Plugin_asserts = _Plugin_asserts
export const Plugin_snapshot = _Plugin_snapshot
export const Plugin_fixture = _Plugin_fixture
export const Plugin_mock = _Plugin_mock

type PI<O extends TestBaseOpts | any = any> =
  | ((t: TestBase, opts: O) => Plug)
  | ((t: TestBase) => Plug)

const plugins: PI[] = [
  Plugin_stdin,
  Plugin_spawn,
  Plugin_before,
  Plugin_beforeEach,
  Plugin_after,
  Plugin_afterEach,
  Plugin_asserts,
  Plugin_snapshot,
  Plugin_fixture,
  Plugin_mock,
]
export const pluginsLoaded = new Map<string, PI>([
  ['stdin', Plugin_stdin],
  ['spawn', Plugin_spawn],
  ['before', Plugin_before],
  ['beforeEach', Plugin_beforeEach],
  ['after', Plugin_after],
  ['afterEach', Plugin_afterEach],
  ['asserts', Plugin_asserts],
  ['snapshot', Plugin_snapshot],
  ['fixture', Plugin_fixture],
  ['mock', Plugin_mock],
])

type Plug =
  | TestBase
  | { t: Test }
  | ReturnType<typeof Plugin_stdin>
  | ReturnType<typeof Plugin_spawn>
  | ReturnType<typeof Plugin_before>
  | ReturnType<typeof Plugin_beforeEach>
  | ReturnType<typeof Plugin_after>
  | ReturnType<typeof Plugin_afterEach>
  | ReturnType<typeof Plugin_asserts>
  | ReturnType<typeof Plugin_snapshot>
  | ReturnType<typeof Plugin_fixture>
  | ReturnType<typeof Plugin_mock>

type PlugKeys =
  | keyof TestBase
  | 't'
  | keyof ReturnType<typeof Plugin_stdin>
  | keyof ReturnType<typeof Plugin_spawn>
  | keyof ReturnType<typeof Plugin_before>
  | keyof ReturnType<typeof Plugin_beforeEach>
  | keyof ReturnType<typeof Plugin_after>
  | keyof ReturnType<typeof Plugin_afterEach>
  | keyof ReturnType<typeof Plugin_asserts>
  | keyof ReturnType<typeof Plugin_snapshot>
  | keyof ReturnType<typeof Plugin_fixture>
  | keyof ReturnType<typeof Plugin_mock>

type SecondParam<
  T extends [any] | [any, any],
> = T extends [any, any] ? T[1] : unknown

export type Plugin_stdin_Opts = SecondParam<
  Parameters<typeof Plugin_stdin>
>
export type Plugin_spawn_Opts = SecondParam<
  Parameters<typeof Plugin_spawn>
>
export type Plugin_before_Opts = SecondParam<
  Parameters<typeof Plugin_before>
>
export type Plugin_beforeEach_Opts = SecondParam<
  Parameters<typeof Plugin_beforeEach>
>
export type Plugin_after_Opts = SecondParam<
  Parameters<typeof Plugin_after>
>
export type Plugin_afterEach_Opts = SecondParam<
  Parameters<typeof Plugin_afterEach>
>
export type Plugin_asserts_Opts = SecondParam<
  Parameters<typeof Plugin_asserts>
>
export type Plugin_snapshot_Opts = SecondParam<
  Parameters<typeof Plugin_snapshot>
>
export type Plugin_fixture_Opts = SecondParam<
  Parameters<typeof Plugin_fixture>
>
export type Plugin_mock_Opts = SecondParam<
  Parameters<typeof Plugin_mock>
>

export type TestOpts = TestBaseOpts
  & Plugin_stdin_Opts
  & Plugin_spawn_Opts
  & Plugin_before_Opts
  & Plugin_beforeEach_Opts
  & Plugin_after_Opts
  & Plugin_afterEach_Opts
  & Plugin_asserts_Opts
  & Plugin_snapshot_Opts
  & Plugin_fixture_Opts
  & Plugin_mock_Opts

type TTest = TestBase
  & ReturnType<typeof Plugin_stdin>
  & ReturnType<typeof Plugin_spawn>
  & ReturnType<typeof Plugin_before>
  & ReturnType<typeof Plugin_beforeEach>
  & ReturnType<typeof Plugin_after>
  & ReturnType<typeof Plugin_afterEach>
  & ReturnType<typeof Plugin_asserts>
  & ReturnType<typeof Plugin_snapshot>
  & ReturnType<typeof Plugin_fixture>
  & ReturnType<typeof Plugin_mock>


export interface Test extends TTest {
  end(): this
  test(
    name: string,
    extra: { [k: string]: any },
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  test(
    name: string,
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  test(
    extra: { [k: string]: any },
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  test(cb?: (t: Test) => any): Promise<FinalResults | null>
  test(
    ...args: TestArgs<Test>
  ): Promise<FinalResults | null>

  todo(
    name: string,
    extra: { [k: string]: any },
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  todo(
    name: string,
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  todo(
    extra: { [k: string]: any },
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  todo(cb?: (t: Test) => any): Promise<FinalResults | null>
  todo(
    ...args: TestArgs<Test>
  ): Promise<FinalResults | null>

  skip(
    name: string,
    extra: { [k: string]: any },
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  skip(
    name: string,
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  skip(
    extra: { [k: string]: any },
    cb?: (t: Test) => any
  ): Promise<FinalResults | null>
  skip(cb?: (t: Test) => any): Promise<FinalResults | null>
  skip(
    ...args: TestArgs<Test>
  ): Promise<FinalResults | null>
}

const applyPlugins = (
  base: Test,
  ext: Plug[] = [
    ...plugins.map(p => p(base, base.options)),
    base,
  ]
): Test => {
  const getCache = new Map<any, any>()
  // extend the proxy with Object.create, and then set the toStringTag
  // to 'Test', so we don't get stack frames like `Proxy.<anonymous>`
  const t = Object.create(new Proxy(base, {
    has(_, p) {
      for (const t of ext) {
        if (Reflect.has(t, p)) return true
      }
      return false
    },
    ownKeys() {
      const k: PlugKeys[] = []
      for (const t of ext) {
        const keys = Reflect.ownKeys(t) as PlugKeys[]
        k.push(...keys)
      }
      return [...new Set(k)]
    },
    getOwnPropertyDescriptor(_, p) {
      for (const t of ext) {
        const prop = Reflect.getOwnPropertyDescriptor(t, p)
        if (prop) return prop
      }
      return undefined
    },
    set(_, p, v) {
      // check to see if there's any setters, and if so, set it there
      // otherwise, just set on the base
      for (const t of ext) {
        let o: Object | null = t
        while (o) {
          if (Reflect.getOwnPropertyDescriptor(o, p)?.set) {
            //@ts-ignore
            t[p] = v
            return true
          }
          o = Reflect.getPrototypeOf(o)
        }
      }
      //@ts-ignore
      base[p as keyof TestBase] = v
      return true
    },
    get(_, p) {
      if (p === 'IS_PLUGGED') return true
      if (p === Symbol.toStringTag) return 'Test'
      if (p === 'parent') {
        return base.parent?.t
      }
      // cache get results so t.blah === t.blah
      // we only cache functions, so that getters aren't memoized
      // Of course, a getter that returns a function will be broken,
      // at least when accessed from outside the plugin, but that's
      // a pretty narrow caveat, and easily documented.
      if (getCache.has(p)) return getCache.get(p)
      for (const plug of ext) {
        if (p in plug) {
          //@ts-ignore
          const v = plug[p]
          // Functions need special handling so that they report
          // the correct toString and are called on the correct object
          // Otherwise attempting to access #private props will fail.
          if (typeof v === 'function') {
            const vv = copyFunction(t, plug, v)
            getCache.set(p, vv)
            return vv
          } else if (p === 'parent') {
            return v?.t
          } else {
            return v
          }
        }
      }
    },
  }))
  Object.defineProperty(t, Symbol.toStringTag, { value: 'Test' })
  Object.assign(base, { t })
  ext.unshift({ t })
  return t
}

export class Test extends TestBase {
  constructor(opts: TestOpts) {
    super(opts)
    return applyPlugins(this)
  }

  static get plugins() {
    return pluginsLoaded
  }

  static pluginLoaded(
    plugin: (t: TestBase, opts?: any) => any
  ): boolean {
    return plugins.includes(plugin)
  }

  test(
    name: string,
    extra: { [k: string]: any },
    cb: (t: Test) => any
  ): Promise<FinalResults | null>
  test(
    name: string,
    cb: (t: Test) => any
  ): Promise<FinalResults | null>
  test(
    extra: { [k: string]: any },
    cb: (t: Test) => any
  ): Promise<FinalResults | null>
  test(cb: (t: Test) => any): Promise<FinalResults | null>
  test(
    ...args: TestArgs<Test>
  ): Promise<FinalResults | null> {
    const extra = parseTestArgs(...args)
    return this.sub(Test, extra, this.test)
  }

  todo(
    name: string,
    extra: { [k: string]: any },
    cb: (t: Test) => any
  ): Promise<FinalResults | null>
  todo(
    name: string,
    cb: (t: Test) => any
  ): Promise<FinalResults | null>
  todo(
    extra: { [k: string]: any },
    cb: (t: Test) => any
  ): Promise<FinalResults | null>
  todo(cb: (t: Test) => any): Promise<FinalResults | null>
  todo(
    ...args: TestArgs<Test>
  ): Promise<FinalResults | null> {
    const extra = parseTestArgs(...args)
    extra.todo = true
    return this.sub(Test, extra, this.todo)
  }

  skip(
    name: string,
    extra: { [k: string]: any },
    cb: (t: Test) => any
  ): Promise<FinalResults | null>
  skip(
    name: string,
    cb: (t: Test) => any
  ): Promise<FinalResults | null>
  skip(
    extra: { [k: string]: any },
    cb: (t: Test) => any
  ): Promise<FinalResults | null>
  skip(cb: (t: Test) => any): Promise<FinalResults | null>
  skip(
    ...args: TestArgs<Test>
  ): Promise<FinalResults | null> {
    const extra = parseTestArgs(...args)
    extra.skip = true
    return this.sub(Test, extra, this.skip)
  }
}
