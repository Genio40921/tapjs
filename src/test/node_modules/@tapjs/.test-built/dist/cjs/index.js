"use strict";
// This file is automatically generated, please do not edit
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Test = exports.signature = exports.loaders = exports.config = exports.pluginsLoaded = exports.Plugin_snapshot = exports.Plugin_mock = exports.Plugin_intercept = exports.Plugin_fixture = exports.Plugin_filter = exports.Plugin_stdin = exports.Plugin_spawn = exports.Plugin_beforeEach = exports.Plugin_before = exports.Plugin_afterEach = exports.Plugin_after = exports.Plugin_asserts = void 0;
const core_1 = require("@tapjs/core");
const jackspeak_1 = require("jackspeak");
const copyToString = (v) => ({
    toString: Object.assign(() => v.toString(), {
        toString: () => 'function toString() { [native code] }',
    }),
});
const copyFunction = (t, plug, v) => {
    const f = function (...args) {
        const thisArg = this === t ? plug : this;
        return v.apply(thisArg, args);
    };
    const vv = Object.assign(f, copyToString(v));
    const nameProp = Reflect.getOwnPropertyDescriptor(v, 'name');
    if (nameProp) {
        Reflect.defineProperty(f, 'name', nameProp);
    }
    return vv;
};
const _Plugin_asserts = __importStar(require("@tapjs/asserts"));
const _Plugin_after = __importStar(require("@tapjs/core/plugin/after"));
const _Plugin_afterEach = __importStar(require("@tapjs/core/plugin/after-each"));
const _Plugin_before = __importStar(require("@tapjs/core/plugin/before"));
const _Plugin_beforeEach = __importStar(require("@tapjs/core/plugin/before-each"));
const _Plugin_spawn = __importStar(require("@tapjs/core/plugin/spawn"));
const _Plugin_stdin = __importStar(require("@tapjs/core/plugin/stdin"));
const _Plugin_filter = __importStar(require("@tapjs/filter"));
const _Plugin_fixture = __importStar(require("@tapjs/fixture"));
const _Plugin_intercept = __importStar(require("@tapjs/intercept"));
const _Plugin_mock = __importStar(require("@tapjs/mock"));
const _Plugin_snapshot = __importStar(require("@tapjs/snapshot"));
exports.Plugin_asserts = _Plugin_asserts.plugin;
exports.Plugin_after = _Plugin_after.plugin;
exports.Plugin_afterEach = _Plugin_afterEach.plugin;
exports.Plugin_before = _Plugin_before.plugin;
exports.Plugin_beforeEach = _Plugin_beforeEach.plugin;
exports.Plugin_spawn = _Plugin_spawn.plugin;
exports.Plugin_stdin = _Plugin_stdin.plugin;
exports.Plugin_filter = _Plugin_filter.plugin;
exports.Plugin_fixture = _Plugin_fixture.plugin;
exports.Plugin_intercept = _Plugin_intercept.plugin;
exports.Plugin_mock = _Plugin_mock.plugin;
exports.Plugin_snapshot = _Plugin_snapshot.plugin;
const plugins = [
    exports.Plugin_asserts,
    exports.Plugin_after,
    exports.Plugin_afterEach,
    exports.Plugin_before,
    exports.Plugin_beforeEach,
    exports.Plugin_spawn,
    exports.Plugin_stdin,
    exports.Plugin_filter,
    exports.Plugin_fixture,
    exports.Plugin_intercept,
    exports.Plugin_mock,
    exports.Plugin_snapshot,
];
exports.pluginsLoaded = new Map([
    ['asserts', exports.Plugin_asserts],
    ['after', exports.Plugin_after],
    ['afterEach', exports.Plugin_afterEach],
    ['before', exports.Plugin_before],
    ['beforeEach', exports.Plugin_beforeEach],
    ['spawn', exports.Plugin_spawn],
    ['stdin', exports.Plugin_stdin],
    ['filter', exports.Plugin_filter],
    ['fixture', exports.Plugin_fixture],
    ['intercept', exports.Plugin_intercept],
    ['mock', exports.Plugin_mock],
    ['snapshot', exports.Plugin_snapshot],
]);
const config = (jack) => {
    const config_0 = _Plugin_filter.config["only"];
    if (!(0, jackspeak_1.isConfigOption)(config_0, "boolean", false)) {
        throw new Error("Invalid config option \"only\" defined in plugin: @tapjs/filter");
    }
    const config_1 = _Plugin_filter.config["grep"];
    if (!(0, jackspeak_1.isConfigOption)(config_1, "string", true)) {
        throw new Error("Invalid config option \"grep\" defined in plugin: @tapjs/filter");
    }
    const config_2 = _Plugin_filter.config["invert"];
    if (!(0, jackspeak_1.isConfigOption)(config_2, "boolean", false)) {
        throw new Error("Invalid config option \"invert\" defined in plugin: @tapjs/filter");
    }
    const config_3 = _Plugin_filter.config["no-invert"];
    if (!(0, jackspeak_1.isConfigOption)(config_3, "boolean", false)) {
        throw new Error("Invalid config option \"no-invert\" defined in plugin: @tapjs/filter");
    }
    const config_4 = _Plugin_fixture.config["save-fixture"];
    if (!(0, jackspeak_1.isConfigOption)(config_4, "boolean", false)) {
        throw new Error("Invalid config option \"save-fixture\" defined in plugin: @tapjs/fixture");
    }
    const config_5 = _Plugin_snapshot.config["snapshot"];
    if (!(0, jackspeak_1.isConfigOption)(config_5, "boolean", false)) {
        throw new Error("Invalid config option \"snapshot\" defined in plugin: @tapjs/snapshot");
    }
    return jack
        .heading("From plugin: @tapjs/filter")
        .flag({ ["only"]: config_0 })
        .optList({ ["grep"]: config_1 })
        .flag({ ["invert"]: config_2 })
        .flag({ ["no-invert"]: config_3 })
        .heading("From plugin: @tapjs/fixture")
        .flag({ ["save-fixture"]: config_4 })
        .heading("From plugin: @tapjs/snapshot")
        .flag({ ["snapshot"]: config_5 });
};
exports.config = config;
exports.loaders = [
    "ts-node/esm",
    "@tapjs/mock/loader"
];
exports.signature = "@tapjs/asserts\n@tapjs/core/plugin/after\n@tapjs/core/plugin/after-each\n@tapjs/core/plugin/before\n@tapjs/core/plugin/before-each\n@tapjs/core/plugin/spawn\n@tapjs/core/plugin/stdin\n@tapjs/core/plugin/typescript\n@tapjs/filter\n@tapjs/fixture\n@tapjs/intercept\n@tapjs/mock\n@tapjs/snapshot";
const applyPlugins = (base, ext = [
    ...plugins.map(p => p(base, base.options)),
    base,
]) => {
    const getCache = new Map();
    // extend the proxy with Object.create, and then set the toStringTag
    // to 'Test', so we don't get stack frames like `Proxy.<anonymous>`
    const t = Object.create(new Proxy(base, {
        has(_, p) {
            for (const t of ext) {
                if (Reflect.has(t, p))
                    return true;
            }
            return false;
        },
        ownKeys() {
            const k = [];
            for (const t of ext) {
                const keys = Reflect.ownKeys(t);
                k.push(...keys);
            }
            return [...new Set(k)];
        },
        getOwnPropertyDescriptor(_, p) {
            for (const t of ext) {
                const prop = Reflect.getOwnPropertyDescriptor(t, p);
                if (prop)
                    return prop;
            }
            return undefined;
        },
        set(_, p, v) {
            // check to see if there's any setters, and if so, set it there
            // otherwise, just set on the base
            let didSet = false;
            if (getCache.has(p))
                getCache.delete(p);
            for (const t of ext) {
                let o = t;
                while (o) {
                    // assign to the all plugs that can receive it
                    const prop = Reflect.getOwnPropertyDescriptor(o, p);
                    if (prop) {
                        if (prop.set || prop.writable) {
                            //@ts-ignore
                            t[p] = v;
                            didSet = true;
                        }
                        break;
                    }
                    o = Reflect.getPrototypeOf(o);
                }
            }
            if (!didSet) {
                // if nothing has that field, assign to the base
                //@ts-ignore
                base[p] = v;
            }
            return true;
        },
        get(_, p) {
            if (p === Symbol.toStringTag)
                return 'Test';
            if (p === 'parent') {
                return base.parent?.t;
            }
            // cache get results so t.blah === t.blah
            // we only cache functions, so that getters aren't memoized
            // Of course, a getter that returns a function will be broken,
            // at least when accessed from outside the plugin, but that's
            // a pretty narrow caveat, and easily documented.
            if (getCache.has(p))
                return getCache.get(p);
            for (const plug of ext) {
                if (p in plug) {
                    //@ts-ignore
                    const v = plug[p];
                    // Functions need special handling so that they report
                    // the correct toString and are called on the correct object
                    // Otherwise attempting to access #private props will fail.
                    if (typeof v === 'function') {
                        const vv = copyFunction(t, plug, v);
                        getCache.set(p, vv);
                        return vv;
                    }
                    else if (p === 'parent') {
                        return v?.t;
                    }
                    else {
                        return v;
                    }
                }
            }
        },
    }));
    Object.defineProperty(t, Symbol.toStringTag, {
        value: 'Test',
    });
    Object.assign(base, { t });
    ext.unshift({ t });
    return t;
};
class Test extends core_1.TestBase {
    constructor(opts) {
        super(opts);
        return applyPlugins(this);
    }
    static get plugins() {
        return exports.pluginsLoaded;
    }
    static pluginLoaded(
    // TS gets confused if we type this as "TestBase" for some reason
    plugin) {
        return plugins.includes(plugin);
    }
    pluginLoaded(
    // TS gets confused if we type this as "TestBase" for some reason
    plugin) {
        return Test.pluginLoaded(plugin);
    }
    get plugins() {
        return Test.plugins;
    }
    test(...args) {
        const extra = (0, core_1.parseTestArgs)(...args);
        return this.sub(Test, extra, this.test);
    }
    todo(...args) {
        const extra = (0, core_1.parseTestArgs)(...args);
        extra.todo = true;
        return this.sub(Test, extra, this.todo);
    }
    skip(...args) {
        const extra = (0, core_1.parseTestArgs)(...args);
        extra.skip = true;
        return this.sub(Test, extra, this.skip);
    }
}
exports.Test = Test;
//# sourceMappingURL=index.js.map