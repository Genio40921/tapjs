import { PromiseWithSubtest, TapPlugin, TestArgs, TestBase, TestBaseOpts } from '@tapjs/core';
import * as Plugin_after from "@tapjs/after";
import * as Plugin_afterEach from "@tapjs/after-each";
import * as Plugin_asserts from "@tapjs/asserts";
import * as Plugin_before from "@tapjs/before";
import * as Plugin_beforeEach from "@tapjs/before-each";
import * as Plugin_filter from "@tapjs/filter";
import * as Plugin_fixture from "@tapjs/fixture";
import * as Plugin_intercept from "@tapjs/intercept";
import * as Plugin_mock from "@tapjs/mock";
import * as Plugin_snapshot from "@tapjs/snapshot";
import * as Plugin_spawn from "@tapjs/spawn";
import * as Plugin_stdin from "@tapjs/stdin";
import * as Plugin_typescript from "@tapjs/typescript";
import type { ConfigSet, Jack } from 'jackspeak';
type PI<O extends TestBaseOpts | any = any> = ((t: TestBase, opts: O) => Plug) | ((t: TestBase) => Plug);
type PluginResult<P extends ((t: TestBase, opts: any) => any)[]> = P extends [
    infer H extends (t: TestBase, opts: any) => any,
    ...infer T extends ((t: TestBase, opts: any) => any)[]
] ? ReturnType<H> & PluginResult<T> : {};
type AnyReturnValue<A extends ((...a: any[]) => any)[]> = A extends [
    infer H extends (...a: any[]) => any,
    ...infer T extends ((...a: any[]) => any)[]
] ? ReturnType<H> | AnyReturnValue<T> : never;
type Plug = TestBase | {
    t: Test<PluginResult<PluginSet>>;
} | AnyReturnValue<PluginSet>;
type SecondParam<T extends [any] | [any, any]> = T extends [
    any,
    infer S
] ? S : unknown;
export type PluginOpts<P extends ((t: TestBase, opts: any) => any)[]> = P extends [
    infer H extends (t: TestBase, opts: any) => any,
    ...infer T extends ((t: TestBase, opts: any) => any)[]
] ? SecondParam<Parameters<H>> & PluginOpts<T> : {};
export type TestOpts = TestBaseOpts & PluginOpts<PluginSet>;
type PluginSet = [
    typeof Plugin_after.plugin,
    typeof Plugin_afterEach.plugin,
    typeof Plugin_asserts.plugin,
    typeof Plugin_before.plugin,
    typeof Plugin_beforeEach.plugin,
    typeof Plugin_filter.plugin,
    typeof Plugin_fixture.plugin,
    typeof Plugin_intercept.plugin,
    typeof Plugin_mock.plugin,
    typeof Plugin_snapshot.plugin,
    typeof Plugin_spawn.plugin,
    typeof Plugin_stdin.plugin,
    typeof Plugin_typescript.plugin
];
export declare const config: <C extends ConfigSet>(jack: Jack<C>) => Jack<C & import("jackspeak").ConfigSetFromMetaSet<"boolean", false, {
    only: {
        type: string;
        short: string;
        description: string;
    } & {
        type: "boolean";
        short?: string | undefined;
        default?: boolean | undefined;
        description?: string | undefined;
        hint?: undefined;
        validate?: ((v: any) => v is boolean) | undefined;
    } & {
        multiple?: false | undefined;
        delim?: undefined;
    };
}> & import("jackspeak").ConfigSetFromMetaSet<"string", true, {
    grep: {
        type: string;
        multiple: boolean;
        hint: string;
        short: string;
        description: string;
    } & {
        type: "string";
        short?: string | undefined;
        default?: string[] | undefined;
        description?: string | undefined;
        hint?: string | undefined;
        validate?: ((v: any) => v is string[]) | undefined;
    } & {
        multiple: true;
        delim?: string | undefined;
    };
}> & import("jackspeak").ConfigSetFromMetaSet<"boolean", false, {
    invert: {
        type: string;
        short: string;
        description: string;
    } & {
        type: "boolean";
        short?: string | undefined;
        default?: boolean | undefined;
        description?: string | undefined;
        hint?: undefined;
        validate?: ((v: any) => v is boolean) | undefined;
    } & {
        multiple?: false | undefined;
        delim?: undefined;
    };
}> & import("jackspeak").ConfigSetFromMetaSet<"boolean", false, {
    "no-invert": {
        type: string;
        short: string;
        description: string;
    } & {
        type: "boolean";
        short?: string | undefined;
        default?: boolean | undefined;
        description?: string | undefined;
        hint?: undefined;
        validate?: ((v: any) => v is boolean) | undefined;
    } & {
        multiple?: false | undefined;
        delim?: undefined;
    };
}> & import("jackspeak").ConfigSetFromMetaSet<"boolean", false, {
    "save-fixture": {
        type: string;
        short: string;
        description: string;
    } & {
        type: "boolean";
        short?: string | undefined;
        default?: boolean | undefined;
        description?: string | undefined;
        hint?: undefined;
        validate?: ((v: any) => v is boolean) | undefined;
    } & {
        multiple?: false | undefined;
        delim?: undefined;
    };
}> & import("jackspeak").ConfigSetFromMetaSet<"boolean", false, {
    snapshot: {
        type: string;
        short: string;
        description: string;
    } & {
        type: "boolean";
        short?: string | undefined;
        default?: boolean | undefined;
        description?: string | undefined;
        hint?: undefined;
        validate?: ((v: any) => v is boolean) | undefined;
    } & {
        multiple?: false | undefined;
        delim?: undefined;
    };
}> & import("jackspeak").ConfigSetFromMetaSet<"boolean", false, {
    typecheck: {
        type: string;
        default: boolean;
        description: string;
    } & {
        type: "boolean";
        short?: string | undefined;
        default?: boolean | undefined;
        description?: string | undefined;
        hint?: undefined;
        validate?: ((v: any) => v is boolean) | undefined;
    } & {
        multiple?: false | undefined;
        delim?: undefined;
    };
}>>;
export declare const loaders: string[];
export declare const signature = "@tapjs/after\n@tapjs/after-each\n@tapjs/asserts\n@tapjs/before\n@tapjs/before-each\n@tapjs/filter\n@tapjs/fixture\n@tapjs/intercept\n@tapjs/mock\n@tapjs/snapshot\n@tapjs/spawn\n@tapjs/stdin\n@tapjs/typescript";
type TTest<P extends PluginSet = PluginSet> = TestBase & PluginResult<P>;
export interface Test<Ext extends PluginResult<PluginSet> = PluginResult<PluginSet>> extends TTest {
    end(implicit?: symbol): this;
    test(name: string, extra: TestOpts, cb?: (t: Test<Ext> & Ext) => any): PromiseWithSubtest<Test<Ext> & Ext>;
    test(name: string, cb?: (t: Test<Ext> & Ext) => any): PromiseWithSubtest<Test<Ext>>;
    test(extra: TestOpts, cb?: (t: Test<Ext> & Ext) => any): PromiseWithSubtest<Test<Ext> & Ext>;
    test(cb?: (t: Test<Ext> & Ext) => any): PromiseWithSubtest<Test<Ext> & Ext>;
    test(...args: TestArgs<Test<Ext> & Ext>): PromiseWithSubtest<Test<Ext> & Ext>;
    todo(name: string, extra: TestOpts, cb?: (t: Test<Ext> & Ext) => any): PromiseWithSubtest<Test<Ext> & Ext>;
    todo(name: string, cb?: (t: Test<Ext> & Ext) => any): PromiseWithSubtest<Test<Ext> & Ext>;
    todo(extra: TestOpts, cb?: (t: Test<Ext> & Ext) => any): PromiseWithSubtest<Test<Ext> & Ext>;
    todo(cb?: (t: Test<Ext> & Ext) => any): PromiseWithSubtest<Test<Ext> & Ext>;
    todo(...args: TestArgs<Test>): PromiseWithSubtest<Test<Ext> & Ext>;
    skip(name: string, extra: TestOpts, cb?: (t: Test<Ext> & Ext) => any): PromiseWithSubtest<Test<Ext> & Ext>;
    skip(name: string, cb?: (t: Test<Ext> & Ext) => any): PromiseWithSubtest<Test<Ext> & Ext>;
    skip(extra: TestOpts, cb?: (t: Test<Ext> & Ext) => any): PromiseWithSubtest<Test<Ext> & Ext>;
    skip(cb?: (t: Test<Ext> & Ext) => any): PromiseWithSubtest<Test<Ext> & Ext>;
    skip(...args: TestArgs<Test>): PromiseWithSubtest<Test<Ext> & Ext>;
    applyPlugin<B extends Object, O extends unknown = unknown>(plugin: TapPlugin<B, O>): Test<Ext & ReturnType<typeof plugin>> & ReturnType<typeof plugin>;
}
export declare class Test<Ext extends PluginResult<PluginSet> = PluginResult<PluginSet>> extends TestBase {
    constructor(opts: TestOpts);
    static get plugins(): Map<string, PI<any>>;
    static pluginLoaded(plugin: (t: any, opts?: any) => any): boolean;
    pluginLoaded<T extends any = any>(plugin: (t: any, opts?: any) => T): this is TestBase & T;
    get plugins(): Map<string, PI<any>>;
    test(name: string, extra: TestOpts, cb: (t: Test<Ext> & Ext) => any): PromiseWithSubtest<Test<Ext> & Ext>;
    test(name: string, cb: (t: Test<Ext> & Ext) => any): PromiseWithSubtest<Test<Ext> & Ext>;
    test(extra: TestOpts, cb: (t: Test<Ext> & Ext) => any): PromiseWithSubtest<Test<Ext> & Ext>;
    test(cb: (t: Test<Ext> & Ext) => any): PromiseWithSubtest<Test<Ext> & Ext>;
    todo(name: string, extra: TestOpts, cb: (t: Test<Ext> & Ext) => any): PromiseWithSubtest<Test<Ext> & Ext>;
    todo(name: string, cb: (t: Test<Ext> & Ext) => any): PromiseWithSubtest<Test<Ext> & Ext>;
    todo(extra: TestOpts, cb: (t: Test<Ext> & Ext) => any): PromiseWithSubtest<Test<Ext> & Ext>;
    todo(cb: (t: Test<Ext> & Ext) => any): PromiseWithSubtest<Test<Ext> & Ext>;
    skip(name: string, extra: TestOpts, cb: (t: Test<Ext> & Ext) => any): PromiseWithSubtest<Test<Ext> & Ext>;
    skip(name: string, cb: (t: Test<Ext> & Ext) => any): PromiseWithSubtest<Test<Ext> & Ext>;
    skip(extra: TestOpts, cb: (t: Test<Ext> & Ext) => any): PromiseWithSubtest<Test<Ext> & Ext>;
    skip(cb: (t: Test<Ext> & Ext) => any): PromiseWithSubtest<Test<Ext> & Ext>;
}
export {};
//# sourceMappingURL=index.d.ts.map