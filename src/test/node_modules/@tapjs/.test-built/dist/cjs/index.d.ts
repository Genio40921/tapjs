import { PromiseWithSubtest, TestArgs, TestBase, TestBaseOpts } from '@tapjs/core';
export type PromiseWithTest = PromiseWithSubtest<Test>;
import type { ConfigSet, Jack } from 'jackspeak';
import * as _Plugin_after from "@tapjs/after";
import * as _Plugin_afterEach from "@tapjs/after-each";
import * as _Plugin_asserts from "@tapjs/asserts";
import * as _Plugin_before from "@tapjs/before";
import * as _Plugin_beforeEach from "@tapjs/before-each";
import * as _Plugin_filter from "@tapjs/filter";
import * as _Plugin_fixture from "@tapjs/fixture";
import * as _Plugin_intercept from "@tapjs/intercept";
import * as _Plugin_mock from "@tapjs/mock";
import * as _Plugin_snapshot from "@tapjs/snapshot";
import * as _Plugin_spawn from "@tapjs/spawn";
import * as _Plugin_stdin from "@tapjs/stdin";
export declare const Plugin_after: (t: TestBase) => _Plugin_after.After;
export declare const Plugin_afterEach: (t: TestBase) => _Plugin_afterEach.AfterEach;
export declare const Plugin_asserts: (t: TestBase) => _Plugin_asserts.Assertions;
export declare const Plugin_before: (t: TestBase) => _Plugin_before.Before;
export declare const Plugin_beforeEach: (t: TestBase) => _Plugin_beforeEach.BeforeEach;
export declare const Plugin_filter: (t: TestBase, opts: _Plugin_filter.FilterOptions) => _Plugin_filter.Filter;
export declare const Plugin_fixture: (t: TestBase, opts: _Plugin_fixture.TestFixturesOptions) => _Plugin_fixture.TestFixtures;
export declare const Plugin_intercept: (t: TestBase) => _Plugin_intercept.Interceptor;
export declare const Plugin_mock: (t: TestBase) => _Plugin_mock.TapMock;
export declare const Plugin_snapshot: (t: TestBase, opts: _Plugin_snapshot.SnapshotOptions) => _Plugin_snapshot.SnapshotPlugin;
export declare const Plugin_spawn: (t: TestBase) => _Plugin_spawn.SpawnPlugin;
export declare const Plugin_stdin: (t: TestBase) => _Plugin_stdin.StdinPlugin;
export declare const Plugin_typescript: (t: TestBase) => {};
type PI<O extends TestBaseOpts | any = any> = ((t: TestBase, opts: O) => Plug) | ((t: TestBase) => Plug);
export declare const pluginsLoaded: Map<string, PI<any>>;
type Plug = TestBase | {
    t: Test;
} | ReturnType<typeof Plugin_after> | ReturnType<typeof Plugin_afterEach> | ReturnType<typeof Plugin_asserts> | ReturnType<typeof Plugin_before> | ReturnType<typeof Plugin_beforeEach> | ReturnType<typeof Plugin_filter> | ReturnType<typeof Plugin_fixture> | ReturnType<typeof Plugin_intercept> | ReturnType<typeof Plugin_mock> | ReturnType<typeof Plugin_snapshot> | ReturnType<typeof Plugin_spawn> | ReturnType<typeof Plugin_stdin> | ReturnType<typeof Plugin_typescript>;
export declare const config: <C extends ConfigSet>(jack: Jack<C>) => Jack<C & import("jackspeak").ConfigSetFromMetaSet<"boolean", false, {
    only: {
        type: string;
        short: string;
        description: string;
    } & {
        type: "boolean";
        short?: string | undefined;
        default?: boolean | undefined;
        description?: string | undefined;
        hint?: undefined;
        validate?: ((v: any) => v is boolean) | undefined;
    } & {
        multiple?: false | undefined;
        delim?: undefined;
    };
}> & import("jackspeak").ConfigSetFromMetaSet<"string", true, {
    grep: {
        type: string;
        multiple: boolean;
        hint: string;
        short: string;
        description: string;
    } & {
        type: "string";
        short?: string | undefined;
        default?: string[] | undefined;
        description?: string | undefined;
        hint?: string | undefined;
        validate?: ((v: any) => v is string[]) | undefined;
    } & {
        multiple: true;
        delim?: string | undefined;
    };
}> & import("jackspeak").ConfigSetFromMetaSet<"boolean", false, {
    invert: {
        type: string;
        short: string;
        description: string;
    } & {
        type: "boolean";
        short?: string | undefined;
        default?: boolean | undefined;
        description?: string | undefined;
        hint?: undefined;
        validate?: ((v: any) => v is boolean) | undefined;
    } & {
        multiple?: false | undefined;
        delim?: undefined;
    };
}> & import("jackspeak").ConfigSetFromMetaSet<"boolean", false, {
    "no-invert": {
        type: string;
        short: string;
        description: string;
    } & {
        type: "boolean";
        short?: string | undefined;
        default?: boolean | undefined;
        description?: string | undefined;
        hint?: undefined;
        validate?: ((v: any) => v is boolean) | undefined;
    } & {
        multiple?: false | undefined;
        delim?: undefined;
    };
}> & import("jackspeak").ConfigSetFromMetaSet<"boolean", false, {
    "save-fixture": {
        type: string;
        short: string;
        description: string;
    } & {
        type: "boolean";
        short?: string | undefined;
        default?: boolean | undefined;
        description?: string | undefined;
        hint?: undefined;
        validate?: ((v: any) => v is boolean) | undefined;
    } & {
        multiple?: false | undefined;
        delim?: undefined;
    };
}> & import("jackspeak").ConfigSetFromMetaSet<"boolean", false, {
    snapshot: {
        type: string;
        short: string;
        description: string;
    } & {
        type: "boolean";
        short?: string | undefined;
        default?: boolean | undefined;
        description?: string | undefined;
        hint?: undefined;
        validate?: ((v: any) => v is boolean) | undefined;
    } & {
        multiple?: false | undefined;
        delim?: undefined;
    };
}> & import("jackspeak").ConfigSetFromMetaSet<"boolean", false, {
    typecheck: {
        type: string;
        default: boolean;
        description: string;
    } & {
        type: "boolean";
        short?: string | undefined;
        default?: boolean | undefined;
        description?: string | undefined;
        hint?: undefined;
        validate?: ((v: any) => v is boolean) | undefined;
    } & {
        multiple?: false | undefined;
        delim?: undefined;
    };
}>>;
export declare const loaders: string[];
export declare const signature = "@tapjs/after\n@tapjs/after-each\n@tapjs/asserts\n@tapjs/before\n@tapjs/before-each\n@tapjs/filter\n@tapjs/fixture\n@tapjs/intercept\n@tapjs/mock\n@tapjs/snapshot\n@tapjs/spawn\n@tapjs/stdin\n@tapjs/typescript";
type SecondParam<T extends [any] | [any, any]> = T extends [any, any] ? T[1] : unknown;
export type Plugin_after_Opts = SecondParam<Parameters<typeof Plugin_after>>;
export type Plugin_afterEach_Opts = SecondParam<Parameters<typeof Plugin_afterEach>>;
export type Plugin_asserts_Opts = SecondParam<Parameters<typeof Plugin_asserts>>;
export type Plugin_before_Opts = SecondParam<Parameters<typeof Plugin_before>>;
export type Plugin_beforeEach_Opts = SecondParam<Parameters<typeof Plugin_beforeEach>>;
export type Plugin_filter_Opts = SecondParam<Parameters<typeof Plugin_filter>>;
export type Plugin_fixture_Opts = SecondParam<Parameters<typeof Plugin_fixture>>;
export type Plugin_intercept_Opts = SecondParam<Parameters<typeof Plugin_intercept>>;
export type Plugin_mock_Opts = SecondParam<Parameters<typeof Plugin_mock>>;
export type Plugin_snapshot_Opts = SecondParam<Parameters<typeof Plugin_snapshot>>;
export type Plugin_spawn_Opts = SecondParam<Parameters<typeof Plugin_spawn>>;
export type Plugin_stdin_Opts = SecondParam<Parameters<typeof Plugin_stdin>>;
export type Plugin_typescript_Opts = SecondParam<Parameters<typeof Plugin_typescript>>;
export type TestOpts = TestBaseOpts & Plugin_after_Opts & Plugin_afterEach_Opts & Plugin_asserts_Opts & Plugin_before_Opts & Plugin_beforeEach_Opts & Plugin_filter_Opts & Plugin_fixture_Opts & Plugin_intercept_Opts & Plugin_mock_Opts & Plugin_snapshot_Opts & Plugin_spawn_Opts & Plugin_stdin_Opts & Plugin_typescript_Opts;
type TTest = TestBase & ReturnType<typeof Plugin_after> & ReturnType<typeof Plugin_afterEach> & ReturnType<typeof Plugin_asserts> & ReturnType<typeof Plugin_before> & ReturnType<typeof Plugin_beforeEach> & ReturnType<typeof Plugin_filter> & ReturnType<typeof Plugin_fixture> & ReturnType<typeof Plugin_intercept> & ReturnType<typeof Plugin_mock> & ReturnType<typeof Plugin_snapshot> & ReturnType<typeof Plugin_spawn> & ReturnType<typeof Plugin_stdin> & ReturnType<typeof Plugin_typescript>;
export interface Test extends TTest {
    end(implicit?: symbol): this;
    test(name: string, extra: TestOpts, cb?: (t: Test) => any): PromiseWithTest;
    test(name: string, cb?: (t: Test) => any): PromiseWithTest;
    test(extra: TestOpts, cb?: (t: Test) => any): PromiseWithTest;
    test(cb?: (t: Test) => any): PromiseWithTest;
    test(...args: TestArgs<Test>): PromiseWithTest;
    todo(name: string, extra: TestOpts, cb?: (t: Test) => any): PromiseWithTest;
    todo(name: string, cb?: (t: Test) => any): PromiseWithTest;
    todo(extra: TestOpts, cb?: (t: Test) => any): PromiseWithTest;
    todo(cb?: (t: Test) => any): PromiseWithTest;
    todo(...args: TestArgs<Test>): PromiseWithTest;
    skip(name: string, extra: TestOpts, cb?: (t: Test) => any): PromiseWithTest;
    skip(name: string, cb?: (t: Test) => any): PromiseWithTest;
    skip(extra: TestOpts, cb?: (t: Test) => any): PromiseWithTest;
    skip(cb?: (t: Test) => any): PromiseWithTest;
    skip(...args: TestArgs<Test>): PromiseWithTest;
}
export declare class Test extends TestBase {
    constructor(opts: TestOpts);
    static get plugins(): Map<string, PI<any>>;
    static pluginLoaded(plugin: (t: any, opts?: any) => any): boolean;
    pluginLoaded<T extends any = any>(plugin: (t: any, opts?: any) => T): this is TestBase & T;
    get plugins(): Map<string, PI<any>>;
    test(name: string, extra: TestOpts, cb: (t: Test) => any): PromiseWithTest;
    test(name: string, cb: (t: Test) => any): PromiseWithTest;
    test(extra: TestOpts, cb: (t: Test) => any): PromiseWithTest;
    test(cb: (t: Test) => any): PromiseWithTest;
    todo(name: string, extra: TestOpts, cb: (t: Test) => any): PromiseWithTest;
    todo(name: string, cb: (t: Test) => any): PromiseWithTest;
    todo(extra: TestOpts, cb: (t: Test) => any): PromiseWithTest;
    todo(cb: (t: Test) => any): PromiseWithTest;
    skip(name: string, extra: TestOpts, cb: (t: Test) => any): PromiseWithTest;
    skip(name: string, cb: (t: Test) => any): PromiseWithTest;
    skip(extra: TestOpts, cb: (t: Test) => any): PromiseWithTest;
    skip(cb: (t: Test) => any): PromiseWithTest;
}
export {};
//# sourceMappingURL=index.d.ts.map