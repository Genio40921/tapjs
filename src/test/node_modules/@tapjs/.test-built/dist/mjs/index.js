// This file is automatically generated, please do not edit
import { parseTestArgs, TestBase, } from '@tapjs/core';
const copyToString = (v) => ({
    toString: Object.assign(() => v.toString(), {
        toString: () => 'function toString() { [native code] }',
    }),
});
const copyFunction = (t, plug, v) => {
    const f = function (...args) {
        const thisArg = this === t ? plug : this;
        return v.apply(thisArg, args);
    };
    const vv = Object.assign(f, copyToString(v));
    const nameProp = Reflect.getOwnPropertyDescriptor(v, 'name');
    if (nameProp) {
        Reflect.defineProperty(f, 'name', nameProp);
    }
    return vv;
};
import _Plugin_stdin from "@tapjs/core/plugin/stdin";
import _Plugin_spawn from "@tapjs/core/plugin/spawn";
import _Plugin_before from "@tapjs/core/plugin/before";
import _Plugin_beforeEach from "@tapjs/core/plugin/before-each";
import _Plugin_after from "@tapjs/core/plugin/after";
import _Plugin_afterEach from "@tapjs/core/plugin/after-each";
import _Plugin_asserts from "@tapjs/asserts";
import _Plugin_snapshot from "@tapjs/snapshot";
import _Plugin_fixture from "@tapjs/fixture";
export const Plugin_stdin = _Plugin_stdin;
export const Plugin_spawn = _Plugin_spawn;
export const Plugin_before = _Plugin_before;
export const Plugin_beforeEach = _Plugin_beforeEach;
export const Plugin_after = _Plugin_after;
export const Plugin_afterEach = _Plugin_afterEach;
export const Plugin_asserts = _Plugin_asserts;
export const Plugin_snapshot = _Plugin_snapshot;
export const Plugin_fixture = _Plugin_fixture;
const plugins = [
    Plugin_stdin,
    Plugin_spawn,
    Plugin_before,
    Plugin_beforeEach,
    Plugin_after,
    Plugin_afterEach,
    Plugin_asserts,
    Plugin_snapshot,
    Plugin_fixture,
];
export const pluginsLoaded = new Map([
    ['stdin', Plugin_stdin],
    ['spawn', Plugin_spawn],
    ['before', Plugin_before],
    ['beforeEach', Plugin_beforeEach],
    ['after', Plugin_after],
    ['afterEach', Plugin_afterEach],
    ['asserts', Plugin_asserts],
    ['snapshot', Plugin_snapshot],
    ['fixture', Plugin_fixture],
]);
const applyPlugins = (base, ext = [
    ...plugins.map(p => p(base, base.options)),
    base,
]) => {
    const getCache = new Map();
    // extend the proxy with Object.create, and then set the toStringTag
    // to 'Test', so we don't get stack frames like `Proxy.<anonymous>`
    const t = Object.create(new Proxy(base, {
        has(_, p) {
            for (const t of ext) {
                if (Reflect.has(t, p))
                    return true;
            }
            return false;
        },
        ownKeys() {
            const k = [];
            for (const t of ext) {
                const keys = Reflect.ownKeys(t);
                k.push(...keys);
            }
            return [...new Set(k)];
        },
        getOwnPropertyDescriptor(_, p) {
            for (const t of ext) {
                const prop = Reflect.getOwnPropertyDescriptor(t, p);
                if (prop)
                    return prop;
            }
            return undefined;
        },
        set(_, p, v) {
            // check to see if there's any setters, and if so, set it there
            // otherwise, just set on the base
            for (const t of ext) {
                let o = t;
                while (o) {
                    if (Reflect.getOwnPropertyDescriptor(o, p)?.set) {
                        //@ts-ignore
                        t[p] = v;
                        return true;
                    }
                    o = Reflect.getPrototypeOf(o);
                }
            }
            //@ts-ignore
            base[p] = v;
            return true;
        },
        get(_, p) {
            if (p === 'IS_PLUGGED')
                return true;
            if (p === Symbol.toStringTag)
                return 'Test';
            if (p === 'parent') {
                return base.parent?.t;
            }
            // cache get results so t.blah === t.blah
            // we only cache functions, so that getters aren't memoized
            // Of course, a getter that returns a function will be broken,
            // at least when accessed from outside the plugin, but that's
            // a pretty narrow caveat, and easily documented.
            if (getCache.has(p))
                return getCache.get(p);
            for (const plug of ext) {
                if (p in plug) {
                    //@ts-ignore
                    const v = plug[p];
                    // Functions need special handling so that they report
                    // the correct toString and are called on the correct object
                    // Otherwise attempting to access #private props will fail.
                    if (typeof v === 'function') {
                        const vv = copyFunction(t, plug === base ? t : plug, v);
                        getCache.set(p, vv);
                        return vv;
                    }
                    else if (p === 'parent') {
                        return v?.t;
                    }
                    else {
                        return v;
                    }
                }
            }
        },
    }));
    Object.defineProperty(t, Symbol.toStringTag, { value: 'Test' });
    Object.assign(base, { t });
    ext.unshift({ t });
    return t;
};
export class Test extends TestBase {
    constructor(opts) {
        super(opts);
        return applyPlugins(this);
    }
    static get plugins() {
        return pluginsLoaded;
    }
    static pluginLoaded(plugin) {
        return plugins.includes(plugin);
    }
    test(...args) {
        const extra = parseTestArgs(...args);
        return this.sub(Test, extra, this.test);
    }
    todo(...args) {
        const extra = parseTestArgs(...args);
        extra.todo = true;
        return this.sub(Test, extra, this.test);
    }
    skip(...args) {
        const extra = parseTestArgs(...args);
        extra.skip = true;
        return this.sub(Test, extra, this.test);
    }
}
//# sourceMappingURL=index.js.map