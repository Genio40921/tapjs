//{{HEADER COMMENT START}}
// This file is automatically generated, edits will be lost on rebuild
//{{HEADER COMMENT END}}
import { parseTestArgs, TestBase, } from '@tapjs/core';
//{{PLUGIN IMPORT START}}
import * as Plugin_after from "@tapjs/after";
import * as Plugin_afterEach from "@tapjs/after-each";
import * as Plugin_asserts from "@tapjs/asserts";
import * as Plugin_before from "@tapjs/before";
import * as Plugin_beforeEach from "@tapjs/before-each";
import * as Plugin_filter from "@tapjs/filter";
import * as Plugin_fixture from "@tapjs/fixture";
import * as Plugin_intercept from "@tapjs/intercept";
import * as Plugin_mock from "@tapjs/mock";
import * as Plugin_snapshot from "@tapjs/snapshot";
import * as Plugin_spawn from "@tapjs/spawn";
import * as Plugin_stdin from "@tapjs/stdin";
import * as Plugin_typescript from "@tapjs/typescript";
import { isConfigOption } from 'jackspeak';
const copyToString = (v) => ({
    toString: Object.assign(() => v.toString(), {
        toString: () => 'function toString() { [native code] }',
    }),
});
const copyFunction = (t, plug, v) => {
    const f = function (...args) {
        const thisArg = this === t ? plug : this;
        const ret = v.apply(thisArg, args);
        return ret === thisArg ? t : ret;
    };
    const vv = Object.assign(Object.assign(f, v), copyToString(v));
    const nameProp = Reflect.getOwnPropertyDescriptor(v, 'name');
    if (nameProp) {
        Reflect.defineProperty(f, 'name', nameProp);
    }
    return vv;
};
let plugins_;
let pluginsLoaded_;
//{{PLUGINS CODE START}}
// const plugins = () => {
//   if (plugins_) return plugins_
//   return (plugins_ = [])
// }
// type PluginSet = (
//   | TapPlugin<any>
//   | TapPlugin<any, TestBaseOpts>
// )[]
// const pluginsLoaded = () => {
//   if (pluginsLoaded_) return pluginsLoaded_
//   return (pluginsLoaded_ = new Map<string, PI>())
// }
const plugins = () => {
    if (plugins_)
        return plugins_;
    return (plugins_ = [
        Plugin_after.plugin,
        Plugin_afterEach.plugin,
        Plugin_asserts.plugin,
        Plugin_before.plugin,
        Plugin_beforeEach.plugin,
        Plugin_filter.plugin,
        Plugin_fixture.plugin,
        Plugin_intercept.plugin,
        Plugin_mock.plugin,
        Plugin_snapshot.plugin,
        Plugin_spawn.plugin,
        Plugin_stdin.plugin,
        Plugin_typescript.plugin,
    ]);
};
const pluginsLoaded = () => {
    if (pluginsLoaded_)
        return pluginsLoaded_;
    return (pluginsLoaded_ = new Map([
        ['after', Plugin_after.plugin],
        ['afterEach', Plugin_afterEach.plugin],
        ['asserts', Plugin_asserts.plugin],
        ['before', Plugin_before.plugin],
        ['beforeEach', Plugin_beforeEach.plugin],
        ['filter', Plugin_filter.plugin],
        ['fixture', Plugin_fixture.plugin],
        ['intercept', Plugin_intercept.plugin],
        ['mock', Plugin_mock.plugin],
        ['snapshot', Plugin_snapshot.plugin],
        ['spawn', Plugin_spawn.plugin],
        ['stdin', Plugin_stdin.plugin],
        ['typescript', Plugin_typescript.plugin],
    ]));
};
//{{PLUGINS CODE END}}
//{{PLUGINS CONFIG START}}
// // just referenced to keep prettier/tslint happy
// isConfigOption
// const c = <T extends ConfigSet>(j: Jack<T>) => j
// c
export const config = (jack) => {
    const config_Plugin_filter_0 = Plugin_filter.config["only"];
    if (!isConfigOption(config_Plugin_filter_0, "boolean", false)) {
        throw new Error("Invalid config option \"only\" defined in plugin: @tapjs/filter");
    }
    const config_Plugin_filter_1 = Plugin_filter.config["grep"];
    if (!isConfigOption(config_Plugin_filter_1, "string", true)) {
        throw new Error("Invalid config option \"grep\" defined in plugin: @tapjs/filter");
    }
    const config_Plugin_filter_2 = Plugin_filter.config["invert"];
    if (!isConfigOption(config_Plugin_filter_2, "boolean", false)) {
        throw new Error("Invalid config option \"invert\" defined in plugin: @tapjs/filter");
    }
    const config_Plugin_filter_3 = Plugin_filter.config["no-invert"];
    if (!isConfigOption(config_Plugin_filter_3, "boolean", false)) {
        throw new Error("Invalid config option \"no-invert\" defined in plugin: @tapjs/filter");
    }
    const config_Plugin_fixture_0 = Plugin_fixture.config["save-fixture"];
    if (!isConfigOption(config_Plugin_fixture_0, "boolean", false)) {
        throw new Error("Invalid config option \"save-fixture\" defined in plugin: @tapjs/fixture");
    }
    const config_Plugin_snapshot_0 = Plugin_snapshot.config["snapshot"];
    if (!isConfigOption(config_Plugin_snapshot_0, "boolean", false)) {
        throw new Error("Invalid config option \"snapshot\" defined in plugin: @tapjs/snapshot");
    }
    const config_Plugin_typescript_0 = Plugin_typescript.config["typecheck"];
    if (!isConfigOption(config_Plugin_typescript_0, "boolean", false)) {
        throw new Error("Invalid config option \"typecheck\" defined in plugin: @tapjs/typescript");
    }
    return jack
        .heading("From plugin: @tapjs/filter")
        .flag({ ["only"]: config_Plugin_filter_0 })
        .optList({ ["grep"]: config_Plugin_filter_1 })
        .flag({ ["invert"]: config_Plugin_filter_2 })
        .flag({ ["no-invert"]: config_Plugin_filter_3 })
        .heading("From plugin: @tapjs/fixture")
        .flag({ ["save-fixture"]: config_Plugin_fixture_0 })
        .heading("From plugin: @tapjs/snapshot")
        .flag({ ["snapshot"]: config_Plugin_snapshot_0 })
        .heading("From plugin: @tapjs/typescript")
        .flag({ ["typecheck"]: config_Plugin_typescript_0 });
};
//{{PLUGINS CONFIG END}}
//{{LOADERS START}}
// export const loaders = []
export const loaders = [
    "@tapjs/mock/loader",
    "ts-node/esm"
];
//{{LOADERS END}}
//{{PLUGIN SIGNATURE START}}
// export const signature = ''
export const signature = `@tapjs/after
@tapjs/after-each
@tapjs/asserts
@tapjs/before
@tapjs/before-each
@tapjs/filter
@tapjs/fixture
@tapjs/intercept
@tapjs/mock
@tapjs/snapshot
@tapjs/spawn
@tapjs/stdin
@tapjs/typescript`;
const applyPlugins = (base) => {
    const ext = plugins()
        .map(p => p(base, base.options))
        .concat(base);
    const getCache = new Map();
    // extend the proxy with Object.create, and then set the toStringTag
    // to 'Test', so we don't get stack frames like `Proxy.<anonymous>`
    const t = Object.create(new Proxy(base, {
        has(_, p) {
            for (const t of ext) {
                if (Reflect.has(t, p))
                    return true;
            }
            return false;
        },
        ownKeys() {
            const k = [];
            for (const t of ext) {
                const keys = Reflect.ownKeys(t);
                k.push(...keys);
            }
            return [...new Set(k)];
        },
        getOwnPropertyDescriptor(_, p) {
            for (const t of ext) {
                const prop = Reflect.getOwnPropertyDescriptor(t, p);
                if (prop)
                    return prop;
            }
            return undefined;
        },
        set(_, p, v) {
            // check to see if there's any setters, and if so, set it there
            // otherwise, just set on the base
            let didSet = false;
            if (getCache.has(p))
                getCache.delete(p);
            for (const t of ext) {
                let o = t;
                while (o) {
                    // assign to the all plugs that can receive it
                    const prop = Reflect.getOwnPropertyDescriptor(o, p);
                    if (prop) {
                        if (prop.set || prop.writable) {
                            //@ts-ignore
                            t[p] = v;
                            didSet = true;
                        }
                        break;
                    }
                    o = Reflect.getPrototypeOf(o);
                }
            }
            if (!didSet) {
                // if nothing has that field, assign to the base
                //@ts-ignore
                base[p] = v;
            }
            return true;
        },
        get(_, p) {
            if (p === Symbol.toStringTag)
                return 'Test';
            if (p === 'parent') {
                return base.parent?.t;
            }
            // cache get results so t.blah === t.blah
            // we only cache functions, so that getters aren't memoized
            // Of course, a getter that returns a function will be broken,
            // at least when accessed from outside the plugin, but that's
            // a pretty narrow caveat, and easily documented.
            if (getCache.has(p))
                return getCache.get(p);
            for (const plug of ext) {
                if (p in plug) {
                    //@ts-ignore
                    const v = plug[p];
                    // Functions need special handling so that they report
                    // the correct toString and are called on the correct object
                    // Otherwise attempting to access #private props will fail.
                    if (typeof v === 'function') {
                        const vv = copyFunction(t, plug, v);
                        getCache.set(p, vv);
                        return vv;
                    }
                    else if (p === 'parent') {
                        return v?.t;
                    }
                    else {
                        return v;
                    }
                }
            }
        },
    }));
    Object.defineProperty(t, Symbol.toStringTag, {
        value: 'Test',
    });
    Object.assign(base, { t });
    ext.unshift({ t });
    return t;
};
export class Test extends TestBase {
    constructor(opts) {
        super(opts);
        return applyPlugins(this);
    }
    applyPlugin(plugin) {
        if (this.parent) {
            throw new Error('Plugins can only be applied at run-time to root test');
        }
        if (this.printedResult) {
            throw new Error('Plugins must be applied prior to any tests');
        }
        const ps = plugins();
        // don't add to the list if already present.
        // tell TS to overlook the dynamic type sins
        //@ts-ignore
        if (!ps.includes(plugin)) {
            //@ts-ignore
            ps.push(plugin);
        }
        return applyPlugins(this);
    }
    static get plugins() {
        return pluginsLoaded();
    }
    static pluginLoaded(
    // TS gets confused if we type this as "TestBase" for some reason
    plugin) {
        return plugins().includes(plugin);
    }
    pluginLoaded(
    // TS gets confused if we type this as "TestBase" for some reason
    plugin) {
        return Test.pluginLoaded(plugin);
    }
    get plugins() {
        return Test.plugins;
    }
    test(...args) {
        const extra = parseTestArgs(...args);
        return this.sub(Test, extra, this.test);
    }
    todo(...args) {
        const extra = parseTestArgs(...args);
        extra.todo = true;
        return this.sub(Test, extra, this.todo);
    }
    skip(...args) {
        const extra = parseTestArgs(...args);
        extra.skip = true;
        return this.sub(Test, extra, this.skip);
    }
}
//# sourceMappingURL=index.js.map