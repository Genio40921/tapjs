import { TestArgs, TestBase, TestBaseOpts } from '@tapjs/core';
import { FinalResults } from 'tap-parser';
import type { ConfigSet, Jack } from 'jackspeak';
import * as _Plugin_asserts from "@tapjs/asserts";
import * as _Plugin_spawn from "@tapjs/core/plugin/spawn";
import * as _Plugin_filter from "@tapjs/filter";
import * as _Plugin_fixture from "@tapjs/fixture";
import * as _Plugin_intercept from "@tapjs/intercept";
import * as _Plugin_mock from "@tapjs/mock";
import * as _Plugin_snapshot from "@tapjs/snapshot";
export declare const Plugin_asserts: (t: TestBase) => _Plugin_asserts.Assertions;
export declare const Plugin_after: (t: TestBase) => {
    "__#13@#private": any;
    teardown(fn: () => any): void;
    after(fn: () => any): void;
};
export declare const Plugin_afterEach: (t: TestBase) => {
    "__#14@#private": any;
    afterEach(fn: (t: import("@tapjs/.test-built").Test) => void | Promise<void>): void;
};
export declare const Plugin_before: (t: TestBase) => {
    "__#15@#private": any;
    before(fn: () => any): void;
};
export declare const Plugin_beforeEach: (t: TestBase) => {
    "__#16@#private": any;
    beforeEach(fn: (t: import("@tapjs/.test-built").Test) => void | Promise<void>): void;
};
export declare const Plugin_spawn: (t: TestBase) => {
    "__#6@#private": any;
    spawn(cmd: string): Promise<FinalResults | null>;
    spawn(cmd: string, options: _Plugin_spawn.SpawnOpts, name?: string | undefined): Promise<FinalResults | null>;
    spawn(cmd: string, args: string | string[], name?: string | undefined): Promise<FinalResults | null>;
    spawn(cmd: string, args: string | string[], options: _Plugin_spawn.SpawnOpts, name?: string | undefined): Promise<FinalResults | null>;
};
export declare const Plugin_stdin: (t: TestBase) => {
    "__#17@#private": any;
    stdin(name: string, extra?: import("@tapjs/core").StdinOpts | undefined): Promise<FinalResults | null>;
    stdin(extra?: import("@tapjs/core").StdinOpts | undefined): Promise<FinalResults | null>;
};
export declare const Plugin_filter: (t: TestBase, opts: _Plugin_filter.FilterOptions) => {
    "__#7@#private": any;
    only(name: string, extra: import("@tapjs/.test-built").TestOpts, cb: (t: import("@tapjs/.test-built").Test) => any): Promise<FinalResults | null>;
    only(name: string, cb: (t: import("@tapjs/.test-built").Test) => any): Promise<FinalResults | null>;
    only(extra: import("@tapjs/.test-built").TestOpts, cb: (t: import("@tapjs/.test-built").Test) => any): Promise<FinalResults | null>;
    only(cb: (t: import("@tapjs/.test-built").Test) => any): Promise<FinalResults | null>;
};
export declare const Plugin_fixture: (t: TestBase, opts: _Plugin_fixture.TestFixturesOptions) => _Plugin_fixture.TestFixtures;
export declare const Plugin_intercept: (t: TestBase) => _Plugin_intercept.Interceptor;
export declare const Plugin_mock: (t: TestBase) => _Plugin_mock.TapMock;
export declare const Plugin_snapshot: (t: TestBase, opts: _Plugin_snapshot.SnapshotOptions) => _Plugin_snapshot.SnapshotPlugin;
type PI<O extends TestBaseOpts | any = any> = ((t: TestBase, opts: O) => Plug) | ((t: TestBase) => Plug);
export declare const pluginsLoaded: Map<string, PI<any>>;
type Plug = TestBase | {
    t: Test;
} | ReturnType<typeof Plugin_asserts> | ReturnType<typeof Plugin_after> | ReturnType<typeof Plugin_afterEach> | ReturnType<typeof Plugin_before> | ReturnType<typeof Plugin_beforeEach> | ReturnType<typeof Plugin_spawn> | ReturnType<typeof Plugin_stdin> | ReturnType<typeof Plugin_filter> | ReturnType<typeof Plugin_fixture> | ReturnType<typeof Plugin_intercept> | ReturnType<typeof Plugin_mock> | ReturnType<typeof Plugin_snapshot>;
export declare const config: <C extends ConfigSet>(jack: Jack<C>) => Jack<C & import("jackspeak").ConfigSetFromMetaSet<"boolean", false, {
    only: {
        type: string;
        short: string;
        description: string;
    } & {
        type: "boolean";
        short?: string | undefined;
        default?: boolean | undefined;
        description?: string | undefined;
        hint?: undefined;
        validate?: ((v: any) => v is boolean) | undefined;
    } & {
        multiple?: false | undefined;
        delim?: undefined;
    };
}> & import("jackspeak").ConfigSetFromMetaSet<"string", true, {
    grep: {
        type: string;
        multiple: boolean;
        hint: string;
        short: string;
        description: string;
    } & {
        type: "string";
        short?: string | undefined;
        default?: string[] | undefined;
        description?: string | undefined;
        hint?: string | undefined;
        validate?: ((v: any) => v is string[]) | undefined;
    } & {
        multiple: true;
        delim?: string | undefined;
    };
}> & import("jackspeak").ConfigSetFromMetaSet<"boolean", false, {
    invert: {
        type: string;
        short: string;
        description: string;
    } & {
        type: "boolean";
        short?: string | undefined;
        default?: boolean | undefined;
        description?: string | undefined;
        hint?: undefined;
        validate?: ((v: any) => v is boolean) | undefined;
    } & {
        multiple?: false | undefined;
        delim?: undefined;
    };
}> & import("jackspeak").ConfigSetFromMetaSet<"boolean", false, {
    "no-invert": {
        type: string;
        short: string;
        description: string;
    } & {
        type: "boolean";
        short?: string | undefined;
        default?: boolean | undefined;
        description?: string | undefined;
        hint?: undefined;
        validate?: ((v: any) => v is boolean) | undefined;
    } & {
        multiple?: false | undefined;
        delim?: undefined;
    };
}> & import("jackspeak").ConfigSetFromMetaSet<"boolean", false, {
    "save-fixture": {
        type: string;
        short: string;
        description: string;
    } & {
        type: "boolean";
        short?: string | undefined;
        default?: boolean | undefined;
        description?: string | undefined;
        hint?: undefined;
        validate?: ((v: any) => v is boolean) | undefined;
    } & {
        multiple?: false | undefined;
        delim?: undefined;
    };
}> & import("jackspeak").ConfigSetFromMetaSet<"boolean", false, {
    snapshot: {
        type: string;
        short: string;
        description: string;
    } & {
        type: "boolean";
        short?: string | undefined;
        default?: boolean | undefined;
        description?: string | undefined;
        hint?: undefined;
        validate?: ((v: any) => v is boolean) | undefined;
    } & {
        multiple?: false | undefined;
        delim?: undefined;
    };
}>>;
export declare const signature = "@tapjs/asserts\n@tapjs/core/plugin/after\n@tapjs/core/plugin/after-each\n@tapjs/core/plugin/before\n@tapjs/core/plugin/before-each\n@tapjs/core/plugin/spawn\n@tapjs/core/plugin/stdin\n@tapjs/filter\n@tapjs/fixture\n@tapjs/intercept\n@tapjs/mock\n@tapjs/snapshot";
type SecondParam<T extends [any] | [any, any]> = T extends [any, any] ? T[1] : unknown;
export type Plugin_asserts_Opts = SecondParam<Parameters<typeof Plugin_asserts>>;
export type Plugin_after_Opts = SecondParam<Parameters<typeof Plugin_after>>;
export type Plugin_afterEach_Opts = SecondParam<Parameters<typeof Plugin_afterEach>>;
export type Plugin_before_Opts = SecondParam<Parameters<typeof Plugin_before>>;
export type Plugin_beforeEach_Opts = SecondParam<Parameters<typeof Plugin_beforeEach>>;
export type Plugin_spawn_Opts = SecondParam<Parameters<typeof Plugin_spawn>>;
export type Plugin_stdin_Opts = SecondParam<Parameters<typeof Plugin_stdin>>;
export type Plugin_filter_Opts = SecondParam<Parameters<typeof Plugin_filter>>;
export type Plugin_fixture_Opts = SecondParam<Parameters<typeof Plugin_fixture>>;
export type Plugin_intercept_Opts = SecondParam<Parameters<typeof Plugin_intercept>>;
export type Plugin_mock_Opts = SecondParam<Parameters<typeof Plugin_mock>>;
export type Plugin_snapshot_Opts = SecondParam<Parameters<typeof Plugin_snapshot>>;
export type TestOpts = TestBaseOpts & Plugin_asserts_Opts & Plugin_after_Opts & Plugin_afterEach_Opts & Plugin_before_Opts & Plugin_beforeEach_Opts & Plugin_spawn_Opts & Plugin_stdin_Opts & Plugin_filter_Opts & Plugin_fixture_Opts & Plugin_intercept_Opts & Plugin_mock_Opts & Plugin_snapshot_Opts;
type TTest = TestBase & ReturnType<typeof Plugin_asserts> & ReturnType<typeof Plugin_after> & ReturnType<typeof Plugin_afterEach> & ReturnType<typeof Plugin_before> & ReturnType<typeof Plugin_beforeEach> & ReturnType<typeof Plugin_spawn> & ReturnType<typeof Plugin_stdin> & ReturnType<typeof Plugin_filter> & ReturnType<typeof Plugin_fixture> & ReturnType<typeof Plugin_intercept> & ReturnType<typeof Plugin_mock> & ReturnType<typeof Plugin_snapshot>;
export interface Test extends TTest {
    end(): this;
    test(name: string, extra: TestOpts, cb?: (t: Test) => any): Promise<FinalResults | null>;
    test(name: string, cb?: (t: Test) => any): Promise<FinalResults | null>;
    test(extra: TestOpts, cb?: (t: Test) => any): Promise<FinalResults | null>;
    test(cb?: (t: Test) => any): Promise<FinalResults | null>;
    test(...args: TestArgs<Test>): Promise<FinalResults | null>;
    todo(name: string, extra: TestOpts, cb?: (t: Test) => any): Promise<FinalResults | null>;
    todo(name: string, cb?: (t: Test) => any): Promise<FinalResults | null>;
    todo(extra: TestOpts, cb?: (t: Test) => any): Promise<FinalResults | null>;
    todo(cb?: (t: Test) => any): Promise<FinalResults | null>;
    todo(...args: TestArgs<Test>): Promise<FinalResults | null>;
    skip(name: string, extra: TestOpts, cb?: (t: Test) => any): Promise<FinalResults | null>;
    skip(name: string, cb?: (t: Test) => any): Promise<FinalResults | null>;
    skip(extra: TestOpts, cb?: (t: Test) => any): Promise<FinalResults | null>;
    skip(cb?: (t: Test) => any): Promise<FinalResults | null>;
    skip(...args: TestArgs<Test>): Promise<FinalResults | null>;
}
export declare class Test extends TestBase {
    constructor(opts: TestOpts);
    static get plugins(): Map<string, PI<any>>;
    static pluginLoaded(plugin: (t: TestBase, opts?: any) => any): boolean;
    pluginLoaded<T extends any = any>(plugin: (t: TestBase, opts?: any) => T): this is TestBase & T;
    get plugins(): Map<string, PI<any>>;
    test(name: string, extra: TestOpts, cb: (t: Test) => any): Promise<FinalResults | null>;
    test(name: string, cb: (t: Test) => any): Promise<FinalResults | null>;
    test(extra: TestOpts, cb: (t: Test) => any): Promise<FinalResults | null>;
    test(cb: (t: Test) => any): Promise<FinalResults | null>;
    todo(name: string, extra: TestOpts, cb: (t: Test) => any): Promise<FinalResults | null>;
    todo(name: string, cb: (t: Test) => any): Promise<FinalResults | null>;
    todo(extra: TestOpts, cb: (t: Test) => any): Promise<FinalResults | null>;
    todo(cb: (t: Test) => any): Promise<FinalResults | null>;
    skip(name: string, extra: TestOpts, cb: (t: Test) => any): Promise<FinalResults | null>;
    skip(name: string, cb: (t: Test) => any): Promise<FinalResults | null>;
    skip(extra: TestOpts, cb: (t: Test) => any): Promise<FinalResults | null>;
    skip(cb: (t: Test) => any): Promise<FinalResults | null>;
}
export {};
//# sourceMappingURL=index.d.ts.map