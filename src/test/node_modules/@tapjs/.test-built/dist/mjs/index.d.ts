import { TestArgs, TestBase, TestBaseOpts } from '@tapjs/core';
import { FinalResults } from 'tap-parser';
export declare const Plugin_stdin: (t: TestBase) => {
    "__#10@#private": any;
    stdin(name: string, extra?: import("@tapjs/core").StdinOpts | undefined): Promise<FinalResults | null>;
    stdin(extra?: import("@tapjs/core").StdinOpts | undefined): Promise<FinalResults | null>;
};
export declare const Plugin_spawn: (t: TestBase) => {
    "__#2@#private": any;
    spawn(cmd: string): Promise<FinalResults | null>;
    spawn(cmd: string, options: import("@tapjs/core/plugin/spawn").SpawnOpts, name?: string | undefined): Promise<FinalResults | null>;
    spawn(cmd: string, args: string | string[], name?: string | undefined): Promise<FinalResults | null>;
    spawn(cmd: string, args: string | string[], options: import("@tapjs/core/plugin/spawn").SpawnOpts, name?: string | undefined): Promise<FinalResults | null>;
};
export declare const Plugin_before: (t: TestBase) => {
    "__#11@#private": any;
    before(fn: () => any): void;
};
export declare const Plugin_beforeEach: (t: TestBase) => {
    "__#12@#private": any;
    beforeEach(fn: (t: import("@tapjs/.test-built").Test) => void | Promise<void>): void;
};
export declare const Plugin_after: (t: TestBase) => {
    "__#13@#private": any;
    teardown(fn: () => any): void;
    after(fn: () => any): void;
};
export declare const Plugin_afterEach: (t: TestBase) => {
    "__#14@#private": any;
    afterEach(fn: (t: import("@tapjs/.test-built").Test) => void | Promise<void>): void;
};
export declare const Plugin_asserts: (t: TestBase) => import("@tapjs/asserts").Assertions;
export declare const Plugin_snapshot: (t: TestBase, opts: import("@tapjs/snapshot").SnapshotOptions) => import("@tapjs/snapshot").SnapshotPlugin;
export declare const Plugin_fixture: (t: TestBase, opts: import("@tapjs/fixture").TestFixturesOptions) => import("@tapjs/fixture").TestFixtures;
export declare const Plugin_mock: (t: TestBase) => import("@tapjs/mock").TapMock;
type PI<O extends TestBaseOpts | any = any> = ((t: TestBase, opts: O) => Plug) | ((t: TestBase) => Plug);
export declare const pluginsLoaded: Map<string, PI<any>>;
type Plug = TestBase | {
    t: Test;
} | ReturnType<typeof Plugin_stdin> | ReturnType<typeof Plugin_spawn> | ReturnType<typeof Plugin_before> | ReturnType<typeof Plugin_beforeEach> | ReturnType<typeof Plugin_after> | ReturnType<typeof Plugin_afterEach> | ReturnType<typeof Plugin_asserts> | ReturnType<typeof Plugin_snapshot> | ReturnType<typeof Plugin_fixture> | ReturnType<typeof Plugin_mock>;
type SecondParam<T extends [any] | [any, any]> = T extends [any, any] ? T[1] : unknown;
export type Plugin_stdin_Opts = SecondParam<Parameters<typeof Plugin_stdin>>;
export type Plugin_spawn_Opts = SecondParam<Parameters<typeof Plugin_spawn>>;
export type Plugin_before_Opts = SecondParam<Parameters<typeof Plugin_before>>;
export type Plugin_beforeEach_Opts = SecondParam<Parameters<typeof Plugin_beforeEach>>;
export type Plugin_after_Opts = SecondParam<Parameters<typeof Plugin_after>>;
export type Plugin_afterEach_Opts = SecondParam<Parameters<typeof Plugin_afterEach>>;
export type Plugin_asserts_Opts = SecondParam<Parameters<typeof Plugin_asserts>>;
export type Plugin_snapshot_Opts = SecondParam<Parameters<typeof Plugin_snapshot>>;
export type Plugin_fixture_Opts = SecondParam<Parameters<typeof Plugin_fixture>>;
export type Plugin_mock_Opts = SecondParam<Parameters<typeof Plugin_mock>>;
export type TestOpts = TestBaseOpts & Plugin_stdin_Opts & Plugin_spawn_Opts & Plugin_before_Opts & Plugin_beforeEach_Opts & Plugin_after_Opts & Plugin_afterEach_Opts & Plugin_asserts_Opts & Plugin_snapshot_Opts & Plugin_fixture_Opts & Plugin_mock_Opts;
type TTest = TestBase & ReturnType<typeof Plugin_stdin> & ReturnType<typeof Plugin_spawn> & ReturnType<typeof Plugin_before> & ReturnType<typeof Plugin_beforeEach> & ReturnType<typeof Plugin_after> & ReturnType<typeof Plugin_afterEach> & ReturnType<typeof Plugin_asserts> & ReturnType<typeof Plugin_snapshot> & ReturnType<typeof Plugin_fixture> & ReturnType<typeof Plugin_mock>;
export interface Test extends TTest {
    end(): this;
    test(name: string, extra: {
        [k: string]: any;
    }, cb?: (t: Test) => any): Promise<FinalResults | null>;
    test(name: string, cb?: (t: Test) => any): Promise<FinalResults | null>;
    test(extra: {
        [k: string]: any;
    }, cb?: (t: Test) => any): Promise<FinalResults | null>;
    test(cb?: (t: Test) => any): Promise<FinalResults | null>;
    test(...args: TestArgs<Test>): Promise<FinalResults | null>;
    todo(name: string, extra: {
        [k: string]: any;
    }, cb?: (t: Test) => any): Promise<FinalResults | null>;
    todo(name: string, cb?: (t: Test) => any): Promise<FinalResults | null>;
    todo(extra: {
        [k: string]: any;
    }, cb?: (t: Test) => any): Promise<FinalResults | null>;
    todo(cb?: (t: Test) => any): Promise<FinalResults | null>;
    todo(...args: TestArgs<Test>): Promise<FinalResults | null>;
    skip(name: string, extra: {
        [k: string]: any;
    }, cb?: (t: Test) => any): Promise<FinalResults | null>;
    skip(name: string, cb?: (t: Test) => any): Promise<FinalResults | null>;
    skip(extra: {
        [k: string]: any;
    }, cb?: (t: Test) => any): Promise<FinalResults | null>;
    skip(cb?: (t: Test) => any): Promise<FinalResults | null>;
    skip(...args: TestArgs<Test>): Promise<FinalResults | null>;
}
export declare class Test extends TestBase {
    constructor(opts: TestOpts);
    static get plugins(): Map<string, PI<any>>;
    static pluginLoaded(plugin: (t: TestBase, opts?: any) => any): boolean;
    pluginLoaded<T extends any = any>(plugin: (t: TestBase, opts?: any) => T): this is TestBase & T;
    get plugins(): Map<string, PI<any>>;
    test(name: string, extra: {
        [k: string]: any;
    }, cb: (t: Test) => any): Promise<FinalResults | null>;
    test(name: string, cb: (t: Test) => any): Promise<FinalResults | null>;
    test(extra: {
        [k: string]: any;
    }, cb: (t: Test) => any): Promise<FinalResults | null>;
    test(cb: (t: Test) => any): Promise<FinalResults | null>;
    todo(name: string, extra: {
        [k: string]: any;
    }, cb: (t: Test) => any): Promise<FinalResults | null>;
    todo(name: string, cb: (t: Test) => any): Promise<FinalResults | null>;
    todo(extra: {
        [k: string]: any;
    }, cb: (t: Test) => any): Promise<FinalResults | null>;
    todo(cb: (t: Test) => any): Promise<FinalResults | null>;
    skip(name: string, extra: {
        [k: string]: any;
    }, cb: (t: Test) => any): Promise<FinalResults | null>;
    skip(name: string, cb: (t: Test) => any): Promise<FinalResults | null>;
    skip(extra: {
        [k: string]: any;
    }, cb: (t: Test) => any): Promise<FinalResults | null>;
    skip(cb: (t: Test) => any): Promise<FinalResults | null>;
}
export {};
//# sourceMappingURL=index.d.ts.map