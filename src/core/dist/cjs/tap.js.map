{"version":3,"file":"tap.js","sourceRoot":"","sources":["../../src/tap.ts"],"names":[],"mappings":"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","sourcesContent":["// The root Test object singleton\nimport { Test } from '@tapjs/test'\nimport { Minipass } from 'minipass'\nimport { onExit } from 'signal-exit'\nimport { FinalResults } from 'tap-parser'\nimport { diags } from './diags.js'\nimport { IMPLICIT } from './implicit-end-sigil.js'\nimport { Extra } from './index.js'\nimport { plugin as AfterPlugin } from '@tapjs/after'\nimport { env, proc } from './proc.js'\nimport { TestBase } from './test-base.js'\n\nconst stdout = proc?.stdout\n\nconst privSym = Symbol('private constructor')\ntype PrivateTAPCtor = {\n  [privSym]: true\n}\nconst privateTAPCtor: PrivateTAPCtor = {\n  [privSym]: true,\n}\n\nlet instance: TAP | undefined = undefined\n\nconst envFlag = (key: string) =>\n  env[key] === undefined ? undefined : env[key] === '1'\n\nlet piped = false\nlet registered = false\nlet autoend = false\n\n/**\n * This is a singleton subclass of the {@link Test} base class.\n *\n * Instantiate it by calling the exported {@link tap} method.\n *\n * It has all of the same plugins, fields, properties etc of a \"normal\"\n * Test object, but with some additional characteristics to make it\n * suitable for use as the root test runner.\n *\n * - The {@link TAP#register} method will hook onto the process object,\n *   to set the exit code to 1 if there are test failures, and ignore any\n *   `EPIPE` errors that happen on stdout.  (This is quite common in cases\n *   where a test aborts, and then attempts to write more data.)\n *\n * - A brief summary is printed at the end of the test run.\n *\n * - If piped to stdout, then `this.register()` will be called automatically.\n *\n * - If not piped anywhere else, the first time it writes any data, it will\n *   begin piping to stdout.\n *\n * - Options are set based on relevant environment variables, rather than\n *   taking an options object, since in normal cases, it will be instantiated\n *   automatically before any user code is run.\n *\n * - The test will automatically implicitly end when the process exits.  If\n *   there are any unfinished tests at this time, they will be emitted as\n *   failures.\n *\n * - If a `teardown` function is added, then the test will automatically\n *   implicitly end if it is idle for 3 consecutive `setTimeout` deferrals.\n *   This is a bit of a kludge, but it allows tests to run servers or other\n *   things that would prevent a graceful process exit, and close them down\n *   in a teardown function.\n *\n * - Lastly, since test files are often spawned by the runner using\n *   `t.spawn()`, this class listens for the timeout signal, and attempts to\n *   print diagnostic information about currently active handles and requests,\n *   as these are usually the cause of a test hanging indefinitely.\n */\nclass TAP extends Test {\n  constructor(priv: PrivateTAPCtor) {\n    /* c8 ignore start */\n    if (priv !== privateTAPCtor) {\n      throw new Error(\n        'the TAP singleton should not be instantiated directly'\n      )\n    }\n    /* c8 ignore stop */\n\n    const timeout =\n      Number(process.env.TAP_TIMEOUT || '30') * 1000\n    const options = {\n      name: 'TAP',\n      diagnostic: envFlag('TAP_DIAG'),\n      bail: envFlag('TAP_BAIL'),\n      debug: envFlag('TAP_DEBUG'),\n      omitVersion: envFlag('TAP_OMIT_VERSION'),\n      preserveWhitespace: !envFlag('TAP_OMIT_WHITESPACE'),\n      timeout,\n    }\n\n    super(options)\n    instance = this\n    this.on('idle', () => maybeAutoend())\n    this.on('complete', (results: FinalResults) =>\n      this.#oncomplete(results)\n    )\n\n    // only attach the teardown autoend if we're using the teardown plugin\n    // tell typescript to chill, if it's not defined or defined as something\n    // else.\n    const td = this\n    if (td.pluginLoaded(AfterPlugin)) {\n      const { teardown } = td\n      type TD = typeof teardown\n      td.teardown = (\n        ...args: Parameters<TD>\n      ): ReturnType<TD> => {\n        autoend = true\n        td.teardown = teardown\n        return td.teardown(...args)\n      }\n    }\n\n    this.runMain(() => {})\n  }\n\n  /**\n   * register this tap instance as being in charge of the current process\n   * ignore epipe errors, set exit code, etc.\n   * Happens automatically if piped to stdout.\n   */\n  register() {\n    if (registered) return\n    registered = true\n    registerTimeoutListener()\n    ignoreEPIPE()\n    this.once('bail', () => proc?.exit(1))\n    proc?.once('beforeExit', () => {\n      this.end(IMPLICIT)\n      if (!this.results) {\n        this.endAll()\n      }\n    })\n  }\n\n  /**\n   * Just the normal Minipass.pipe method, but automatically registers\n   * if the destination is stdout.\n   */\n  pipe<W extends Minipass.Writable>(\n    dest: W,\n    opts?: Minipass.PipeOptions\n  ): W {\n    piped = true\n    if (stdout && dest === stdout) {\n      this.register()\n    }\n    return super.pipe(dest, opts)\n  }\n\n  /**\n   * Just the normal Minipass.write method, but automatically pipes\n   * to stdout if not piped anywhere else.\n   */\n  write(chunk: string): boolean {\n    if (!registered && !piped && stdout) {\n      this.pipe(stdout)\n    }\n    return super.write(chunk)\n  }\n\n  #oncomplete(results: FinalResults) {\n    // only print this added info in the root test, otherwise\n    // it's a bit extraneous.\n    if (!env.TAP_CHILD_ID) {\n      this.comment(this.counts.toJSON())\n      this.comment(`time=${this.time}ms`)\n    }\n\n    if (registered && !results.ok && proc) {\n      proc.exitCode = 1\n    }\n  }\n\n  timeout(\n    options: {\n      expired?: string\n      signal?: NodeJS.Signals | null\n    } = { expired: this.name, signal: null }\n  ) {\n    const ret = super.timeout(\n      Object.assign(\n        getTimeoutExtra(options.signal),\n        options\n      )\n    )\n    // don't stick around\n    if (registered) {\n      const t = setTimeout(() => {\n        didProcessTimeout = true\n        alarmKill()\n      }, 100)\n      if (t.unref) t.unref()\n    }\n    return ret\n  }\n}\n\nconst shouldAutoend = (\n  instance: TAP | undefined\n): instance is TAP => !!autoend && !!instance?.idle\n\nlet autoendTimer: NodeJS.Timer | undefined = undefined\nconst maybeAutoend = () => {\n  clearTimeout(autoendTimer)\n  if (!shouldAutoend(instance)) return\n  autoendTimer = setTimeout(() => {\n    clearTimeout(autoendTimer)\n    if (shouldAutoend(instance)) {\n      autoendTimer = setTimeout(() => {\n        clearTimeout(autoendTimer)\n        if (shouldAutoend(instance)) {\n          ;(instance as unknown as TestBase).end(IMPLICIT)\n          autoend = false\n        }\n      })\n    }\n  })\n}\n\nconst registerTimeoutListener = () => {\n  // SIGALRM means being forcibly killed due to timeout\n  const isTimeoutSignal = (signal: NodeJS.Signals | null) =>\n    signal === 'SIGALRM' ||\n    (signal === 'SIGINT' && !process.env.TAP_CHILD_ID)\n  onExit((_, signal) => {\n    if (!isTimeoutSignal(signal) || didProcessTimeout) {\n      return\n    }\n    onProcessTimeout(signal)\n  })\n\n  // this is a bit of a handshake agreement between the root TAP object\n  // and the Spawn class. Because Windows cannot catch and process posix\n  // signals, we have to use an IPC message to send the timeout signal.\n  // t.spawn() will always open an ipc channel on fd 3 for this purpose.\n  // The key and childId are just a basic gut check to ensure that we don't\n  // treat a message as a timeout unintentionally, though of course that\n  // would be extremely rare.\n  process.on(\n    'message',\n    (\n      msg:\n        | {\n            tapAbort?: string\n            key?: string\n            child?: string\n          }\n        | any\n    ) => {\n      if (\n        msg &&\n        typeof msg === 'object' &&\n        msg.tapAbort === 'timeout' &&\n        msg.key === process.env.TAP_ABORT_KEY &&\n        msg.child === process.env.TAP_CHILD_ID\n      ) {\n        onProcessTimeout('SIGALRM')\n      }\n    }\n  )\n  // We don't want the channel to keep the child running\n  //@ts-ignore\n  process.channel?.unref()\n  /* c8 ignore stop */\n}\n\nconst getTimeoutExtra = (\n  signal: NodeJS.Signals | null = null\n) => {\n  const p = process as unknown as {\n    _getActiveHandles: () => any[]\n    _getActiveRequests: () => any[]\n  }\n\n  /* c8 ignore start */\n  const handles = (p._getActiveHandles() || []).filter(\n    /* c8 ignore stop */\n    h =>\n      h !== process.stdout &&\n      h !== process.stdin &&\n      h !== process.stderr\n  )\n  const requests = p._getActiveRequests()\n\n  const extra: Extra = {\n    at: undefined,\n    signal,\n  }\n  if (requests.length) {\n    extra.requests = requests.map(r => {\n      /* c8 ignore start */\n      if (!r || typeof r !== 'object') return r\n      /* c8 ignore stop */\n      const ret: {\n        type: string\n        context?: any\n      } = {\n        type: r.constructor.name,\n      }\n\n      // most everything in node has a context these days\n      /* c8 ignore start */\n      if (r.context) ret.context = r.context\n      /* c8 ignore stop */\n\n      return ret\n    })\n  }\n\n  // Newer node versions don't have this as reliably.\n  /* c8 ignore start */\n  if (handles.length) {\n    extra.handles = handles.map(h => {\n      /* c8 ignore start */\n      if (!h || typeof h !== 'object') return h\n      /* c8 ignore stop */\n\n      const ret: {\n        type: string\n        msecs?: number\n        events?: string[]\n        sockname?: string\n        connectionKey?: string\n      } = {\n        type: h.constructor.name,\n      }\n\n      // all of this is very internal-ish\n      /* c8 ignore start */\n      if (h.msecs) ret.msecs = h.msecs\n      if (h._events) ret.events = Object.keys(h._events)\n      if (h._sockname) ret.sockname = h._sockname\n      if (h._connectionKey)\n        ret.connectionKey = h._connectionKey\n      /* c8 ignore stop */\n\n      return ret\n    })\n  }\n\n  return extra\n}\n\nlet didProcessTimeout = false\nconst onProcessTimeout = (\n  signal: NodeJS.Signals | null = null\n) => {\n  if (didProcessTimeout || !instance) return\n  didProcessTimeout = true\n\n  const extra = getTimeoutExtra(signal)\n\n  if (signal === 'SIGINT') {\n    extra.message = 'interrupt!'\n  }\n\n  // ignore coverage here because it happens after everything\n  // must have been shut down.\n  /* c8 ignore start */\n  if (!instance.results) {\n    instance.timeout(extra)\n  } else {\n    console.error(\n      'possible timeout: SIGALRM received after tap end'\n    )\n    if (extra.handles || extra.requests) {\n      delete extra.signal\n      if (!extra.at) {\n        delete extra.at\n      }\n    }\n    console.error(diags(extra))\n    alarmKill()\n  }\n}\n\nconst alarmKill = () => {\n  // SIGALRM isn't supported everywhere\n  /* c8 ignore start */\n  try {\n    process.kill(process.pid, 'SIGALRM')\n  } catch {\n    process.kill(process.pid, 'SIGKILL')\n  }\n  const t = setTimeout(() => {\n    process.kill(process.pid, 'SIGKILL')\n  }, 500)\n  /* c8 ignore stop */\n  if (t.unref) t.unref()\n}\n\nconst ignoreEPIPE = () => {\n  /* c8 ignore start */\n  if (!stdout?.emit) return\n  /* c8 ignore stop */\n  const emit = stdout.emit\n  stdout.emit = (ev: string, ...args: any[]) => {\n    const er = args[0] as NodeJS.ErrnoException\n    if (ev === 'error' && er?.code === 'EPIPE') {\n      return false\n    }\n    //@ts-ignore\n    return emit.call(stdout, ev, ...args)\n  }\n}\n\nexport const tap = () => instance || new TAP(privateTAPCtor)\nexport type { TAP }\n"]}