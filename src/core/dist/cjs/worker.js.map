{"version":3,"file":"worker.js","sourceRoot":"","sources":["../../src/worker.ts"],"names":[],"mappings":"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","sourcesContent":["// the .worker() method is only added to the root test object\n// See https://github.com/tapjs/node-tap/issues/812\nimport { Base, TapBaseEvents } from './base.js'\nimport { TestBaseOpts } from './test-base.js'\nimport { env } from './proc.js'\n\nimport { format } from 'node:util'\nimport { Worker as NodeWorker } from 'node:worker_threads'\nimport { FinalResults } from 'tap-parser'\n\nexport interface WorkerEvents extends TapBaseEvents {}\n\nexport interface WorkerOpts extends TestBaseOpts {\n  workerData?: any\n  threadId?: number\n}\n\nexport class Worker extends Base<WorkerEvents> {\n  declare options: WorkerOpts\n\n  filename: string\n  cb?: () => void\n  #worker?: NodeWorker\n\n  constructor(options: WorkerOpts) {\n    const { filename } = options\n    if (!filename) {\n      throw new TypeError('no filename provided for t.worker()')\n    }\n    super(options)\n    this.filename = filename\n  }\n\n  main(cb: () => void) {\n    this.cb = cb\n    this.setTimeout(this.options.timeout || 0)\n\n    this.parser.on('comment', c => {\n      const tomatch = c.match(/# timeout=([0-9]+)\\n$/)\n      if (tomatch) {\n        this.setTimeout(+tomatch[1])\n      }\n    })\n\n    this.parent?.emit('worker', this)\n\n    this.#worker = new NodeWorker(this.filename, {\n      ...this.options,\n      stdout: true,\n      // TODO: take options.env like Spawn does\n      env: {\n        ...env,\n        TAP: '1',\n        TAP_CHILD_ID: String(this.childId),\n      },\n    })\n    this.#worker.stdout.pipe(this.parser)\n    this.#worker.on('error', e => this.threw(e))\n    this.#worker.on('exit', () => this.setTimeout(0))\n    this.#worker.on('message', m => this.comment(m))\n  }\n\n  // TODO: if we time out, terminate worker like how spawn terminates proc\n\n  // TODO: both parser complete AND workerexit have to happen?\n  // or should we terminate here?  give it a moment to exit if it hasn't?\n  oncomplete(results: FinalResults) {\n    super.oncomplete(results)\n    const { cb } = this\n    /* c8 ignore start */\n    if (!cb) {\n      throw new Error('tap worker finished parser before receiving cb??')\n    }\n    /* c8 ignore stop */\n    cb()\n  }\n\n  // TODO: use message port to send timeout signal like spawn() ipc\n\n  comment(...args: any[]) {\n    const body = format(...args)\n    const message =\n      ('# ' + body.split(/\\r?\\n/).join('\\n# ')).trim() + '\\n'\n    if (this.parser.results) {\n      console.log(message)\n    } else {\n      this.parser.write(message)\n    }\n  }\n}\n"]}