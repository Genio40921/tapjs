{"version":3,"file":"test-base.js","sourceRoot":"","sources":["../../src/test-base.ts"],"names":[],"mappings":"AAAA,yDAAyD;AACzD,kCAAkC;AAElC,OAAO,KAAK,KAAK,MAAM,cAAc,CAAA;AAGrC,OAAO,MAAM,MAAM,aAAa,CAAA;AAChC,OAAO,EAAE,QAAQ,EAAE,MAAM,WAAW,CAAA;AACpC,OAAO,EAAE,MAAM,EAAE,MAAM,cAAc,CAAA;AAErC,OAAO,EAAE,MAAM,EAAE,MAAM,WAAW,CAAA;AAClC,OAAO,EAAE,YAAY,EAAE,MAAM,YAAY,CAAA;AACzC,OAAO,EAAE,QAAQ,EAAE,MAAM,kBAAkB,CAAA;AAC3C,OAAO,EAAE,IAAI,EAAY,MAAM,WAAW,CAAA;AAC1C,OAAO,EAAE,GAAG,EAAE,MAAM,UAAU,CAAA;AAC9B,OAAO,EAAE,cAAc,EAAE,MAAM,uBAAuB,CAAA;AACtD,OAAO,EAAE,UAAU,EAAE,MAAM,kBAAkB,CAAA;AAC7C,OAAO,EAAE,IAAI,EAAE,GAAG,EAAE,MAAM,WAAW,CAAA;AAGrC,OAAO,EAAU,SAAS,EAAE,MAAM,iBAAiB,CAAA;AACnD,OAAO,EAAE,MAAM,EAAE,MAAM,aAAa,CAAA;AAGpC,OAAO,EAAE,QAAQ,EAAE,MAAM,yBAAyB,CAAA;AAElD,OAAO,EAAE,qBAAqB,EAAE,MAAM,8BAA8B,CAAA;AAEpE,MAAM,OAAO,GAAG,kBAAkB,CAAA;AAmBlC,MAAM,UAAU,GAAG,CAAqB,CAAI,EAAE,EAAE,CAC9C,CAAC,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC;IACpB,CAAC,CAAC,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,OAAO,CAAC,CAAA;AASlD;;GAEG;AACH,MAAM,GAAG,GAAG,MAAM,CAAC,KAAK,CAAC,CAAA;AAazB,MAAM,SAAS,GAAG,CAAC,CAAM,EAA4B,EAAE,CACrD,CAAC,CAAC,CAAC,IAAI,OAAO,CAAC,KAAK,QAAQ,IAAI,OAAO,CAAC,CAAC,IAAI,KAAK,UAAU,CAAA;AAyB9D;;;;;;;;GAQG;AACH,MAAM,OAAO,QAAS,SAAQ,IAAoB;IAKhD;;;;;OAKG;IACH,CAAC,CAAO;IAER,WAAW,CAEV;IACD,IAAI,CAAQ;IACZ,QAAQ,GAAW,EAAE,CAAA;IACrB,IAAI,GAAc,IAAI,GAAG,EAAE,CAAA;IAC3B,KAAK,GAAiB,CAAC,OAAO,CAAC,CAAA;IAC/B,EAAE,CAA0B;IAC5B,KAAK,GAAW,CAAC,CAAA;IACjB,KAAK,GAAY,KAAK,CAAA;IACtB,UAAU,GAAmB,IAAI,CAAA;IAEjC,QAAQ,GAAW,CAAC,CAAC,CAAA;IACrB,cAAc,GAAY,KAAK,CAAA;IAC/B,cAAc,GAAY,KAAK,CAAA;IAC/B,aAAa,GAAY,KAAK,CAAA;IAC9B,aAAa,GAAY,KAAK,CAAA;IAC9B,cAAc,GAAY,KAAK,CAAA;IAC/B,EAAE,GAAW,CAAC,CAAA;IACd,WAAW,GAAY,KAAK,CAAA;IAC5B,SAAS,GAAyB,IAAI,CAAA;IACtC,UAAU,GAAY,KAAK,CAAA;IAC3B,gBAAgB,GAAY,KAAK,CAAA;IACjC,YAAY,GAAW,CAAC,CAAA;IACxB,cAAc,GAA2C,IAAI,CAAA;IAC7D,WAAW,GAAY,KAAK,CAAA;IAC5B,eAAe,GAAY,KAAK,CAAA;IAChC,YAAY,GAAY,KAAK,CAAA;IAE7B;;OAEG;IACH,IAAI,aAAa;QACf,OAAO,IAAI,CAAC,cAAc,CAAA;IAC5B,CAAC;IAED;;OAEG;IACH,IAAI,QAAQ;QACV,OAAO,CAAC,CAAC,IAAI,CAAC,SAAS,CAAA;IACzB,CAAC;IAED,YAAY,OAAqB;QAC/B,KAAK,CAAC,OAAO,CAAC,CAAA;QAEd,IAAI,CAAC,IAAI,GAAG,CAAC,OAAO,CAAC,IAAI,IAAI,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAA;QAE5D,IAAI,OAAO,OAAO,CAAC,UAAU,KAAK,SAAS,EAAE;YAC3C,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC,UAAU,CAAA;SACrC;QAED,IAAI,OAAO,CAAC,EAAE,EAAE;YACd,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,EAAE,CAAC,CAAA;SACxB;IACH,CAAC;IAED,MAAM,CAA8B,EAAiB;QACnD,IAAI,CAAC,EAAE,GAAG,CAAC,GAAG,IAAW,EAAE,EAAE,CAC3B,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,EAAE,EAAE,IAAI,CAAC,CAAC,IAAI,IAAI,EAAE,GAAG,IAAI,CAAC,CAAA;IAC1D,CAAC;IAED,gCAAgC;IAChC;;;OAGG;IACH,OAAO,CAAC,OAAgB;QACtB,IAAI,IAAI,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE;YAC/C,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,CAAA;SAC7B;aAAM;YACL,IAAI,CAAC,QAAQ,EAAE,CAAA;YACf,OAAO,GAAG,OAAO,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,EAAE,CAAA;YACzD,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,SAAS,EAAE,GAAG,CAAC,CAAA;YACzC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,WAAW,GAAG,OAAO,GAAG,IAAI,CAAC,CAAA;SAChD;QACD,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAA;QACnB,IAAI,CAAC,QAAQ,EAAE,CAAA;IACjB,CAAC;IAED;;OAEG;IACH,OAAO,CAAC,GAAG,IAAW;QACpB,MAAM,IAAI,GAAG,MAAM,CAAC,GAAG,IAAI,CAAC,CAAA;QAC5B,MAAM,OAAO,GACX,CAAC,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,EAAE,GAAG,IAAI,CAAA;QAEzD,IAAI,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,UAAU,EAAE;YACjD,8CAA8C;YAC9C,wDAAwD;YACxD,IAAI,IAAI,CAAC,MAAM;gBAAE,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,CAAA;;gBACxC,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC,CAAA;SACpC;aAAM,IAAI,IAAI,CAAC,SAAS,EAAE;YACzB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,CAAA;YACxB,IAAI,CAAC,QAAQ,EAAE,CAAA;SAChB;aAAM;YACL,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAA;SACpB;IACH,CAAC;IAED;;;OAGG;IACH,OAAO,CACL,UAAwC,EAAE,OAAO,EAAE,IAAI,CAAC,IAAI,EAAE;QAE9D,OAAO,CAAC,OAAO,GAAG,OAAO,CAAC,OAAO,IAAI,IAAI,CAAC,IAAI,CAAA;QAC9C,IAAI,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,SAAS,YAAY,IAAI,EAAE;YACpD,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,OAAO,CAAC,CAAA;SAChC;aAAM;YACL,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,CAAA;SACvB;QACD,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAA;IACrB,CAAC;IAED;;;OAGG;IACH,MAAM,CAAC,GAA6B;QAClC,MAAM,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,MAAM,CAC/B,CAAC,GAAG,EAAE,CAAC,EAAE,EAAE,CAAC,GAAG,GAAG,SAAS,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,IAAI,EAC7D,EAAE,CACH,CAAA;QACD,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA;QAClB,IAAI,CAAC,QAAQ,EAAE,CAAA;IACjB,CAAC;IAQD,IAAI,CAAC,CAAS,EAAE,OAAgB,EAAE,QAA0B;QAC1D,IAAI,IAAI,CAAC,SAAS,EAAE;YAClB,OAAM;SACP;QAED,IAAI,IAAI,CAAC,aAAa,EAAE;YACtB,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC,CAAA;SAClD;QACD,IAAI,CAAC,aAAa,GAAG,QAAQ,KAAK,QAAQ,CAAA;QAE1C,IAAI,IAAI,CAAC,QAAQ,KAAK,CAAC,CAAC,EAAE;YACxB,MAAM,IAAI,KAAK,CAAC,sCAAsC,CAAC,CAAA;SACxD;QAED,IAAI,OAAO,CAAC,KAAK,QAAQ,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;YACzD,MAAM,IAAI,SAAS,CAAC,qCAAqC,CAAC,CAAA;SAC3D;QAED,6DAA6D;QAC7D,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;QAE1C,IAAI,CAAC,KAAK,CAAC,IAAI,OAAO,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE;YAC5C,IAAI,CAAC,OAAO,CAAC,IAAI,GAAG,OAAO,CAAA;SAC5B;QAED,IAAI,CAAC,QAAQ,GAAG,CAAC,CAAA;QACjB,OAAO,GAAG,OAAO,CAAC,CAAC,CAAC,KAAK,GAAG,GAAG,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,CAAA;QACpD,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,GAAG,OAAO,GAAG,IAAI,CAAC,CAAA;QAE3C,IAAI,MAAM,EAAE;YACV,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAA;SACpB;aAAM;YACL,IAAI,CAAC,QAAQ,EAAE,CAAA;SAChB;IACH,CAAC;IAED;;OAEG;IACH,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAe;QAChC,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,IAAI,CAAA;QAC9B,MAAM,IAAI,GAAG,CAAC,GAAG,EAAE,KAAK,CAAiB,CAAA;QACzC,MAAM,EAAE,GAAG,qBAAqB,CAAC,gBAAgB,EAAE,IAAI,CAAC,CAAA;QACxD,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,GAAG,EAAE,CAAC,CAAA;QAC7B,OAAO,IAAI,CAAA;IACb,CAAC;IAED;;OAEG;IACH,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAe;QAChC,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,IAAI,CAAA;QAC9B,MAAM,IAAI,GAAG,CAAC,GAAG,EAAE,KAAK,CAAiB,CAAA;QACzC,MAAM,EAAE,GAAG,qBAAqB,CAAC,gBAAgB,EAAE,IAAI,CAAC,CAAA;QACxD,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,GAAG,EAAE,CAAC,CAAA;QAC9B,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAA;IACrC,CAAC;IAED;;;OAGG;IACH,IAAI,aAAa;QACf,OAAO,IAAI,CAAC,cAAc,CAAA;IAC5B,CAAC;IACD;;;OAGG;IACH,IAAI,aAAa,CAAC,EAA4C;QAC5D,IAAI,CAAC,IAAI,CAAC,cAAc,IAAI,OAAO,EAAE,KAAK,UAAU,EAAE;YACpD,IAAI,CAAC,cAAc,GAAG,EAAE,CAAA;SACzB;IACH,CAAC;IAED;;OAEG;IACH,WAAW,CACT,EAAW,EACX,OAAe,EACf,KAAY,EACZ,QAAiB,KAAK;QAEtB,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,WAAW,CAAA;QACrC,IAAI,CAAC,cAAc,GAAG,IAAI,CAAA;QAE1B,MAAM,CAAC,GAAG,IAAI,CAAC,KAAK,GAAG,CAAC,CAAA;QACxB,MAAM,EAAE,GAAG,IAAI,CAAC,aAAa,CAAA;QAC7B,IAAI,CAAC,cAAc,GAAG,IAAI,CAAA;QAE1B,IAAI,IAAI,CAAC,QAAQ,KAAK,CAAC,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,QAAQ,EAAE;YAC7C,oDAAoD;YACpD,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;gBAAE,OAAM;YAE3B,8DAA8D;YAC9D,6DAA6D;YAC7D,+DAA+D;YAC/D,2CAA2C;YAC3C,MAAM,WAAW,GAAG,IAAI,CAAC,cAAc;gBACrC,CAAC,CAAC,uCAAuC;gBACzC,CAAC,CAAC,IAAI,CAAC,aAAa;oBACpB,CAAC,CAAC,yCAAyC;oBAC3C,CAAC,CAAC,IAAI,CAAC,aAAa;wBACpB,CAAC,CAAC,mCAAmC;wBACrC,CAAC,CAAC,qBAAqB;4BACrB,+BAA+B,CAAA;YACnC,oBAAoB;YAEpB,MAAM,EAAE,GAAG,IAAI,KAAK,CAAC,WAAW,EAAE;gBAChC,KAAK,EAAE;oBACL,IAAI,EAAE,IAAI,CAAC,IAAI;oBACf,IAAI,EAAE,IAAI,CAAC,QAAQ;iBACpB;aACF,CAAC,CAAA;YACF,KAAK,CAAC,iBAAiB,CAAC,EAAE,EAAE,EAAE,CAAC,CAAA;YAC/B,IAAI,CAAC,KAAK,CAAC,EAAE,EAAE,cAAc,CAAC,EAAE,CAAC,CAAC,CAAA;YAClC,OAAM;SACP;QAED,IAAI,KAAK,CAAC,UAAU,EAAE;YACpB,EAAE,GAAG,CAAC,EAAE,CAAA;SACT;QAED,IAAI,KAAK,CAAC,EAAE,KAAK,IAAI,EAAE;YACrB,OAAO,KAAK,CAAC,EAAE,CAAA;YACf,OAAO,KAAK,CAAC,KAAK,CAAA;SACnB;aAAM,IACL,OAAO,KAAK,CAAC,KAAK,KAAK,QAAQ;YAC/B,KAAK,CAAC,KAAK;YACX,CAAC,KAAK,CAAC,EAAE,EACT;YACA,MAAM,MAAM,GAAG,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,KAAK,CAAC,CAAA;YAC5C,KAAK,CAAC,EAAE,GAAG,MAAM,CAAC,CAAC,CAAC,CAAA;YACpB,KAAK,CAAC,KAAK,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAA;SACzD;aAAM,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,OAAO,EAAE,KAAK,UAAU,EAAE;YAChD,MAAM,SAAS,GAAG,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,CAAA;YACnD,MAAM,MAAM,GAAG,SAAS,IAAI,KAAK,CAAC,UAAU,KAAK,IAAI,CAAA;YACrD,IAAI,MAAM,EAAE;gBACV,MAAM,EAAE,GAAG,KAAK,CAAC,OAAO,CAAC,EAAE,EAAE,EAAE,CAAC,CAAA;gBAChC,KAAK,CAAC,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC,CAAA;gBAChB,IAAI,SAAS,EAAE;oBACb,KAAK,CAAC,KAAK,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;iBAChD;aACF;SACF;QAED,MAAM,UAAU,GACd,OAAO,KAAK,CAAC,UAAU,KAAK,SAAS;YACnC,CAAC,CAAC,KAAK,CAAC,UAAU;YAClB,CAAC,CAAC,OAAO,IAAI,CAAC,UAAU,KAAK,SAAS;gBACtC,CAAC,CAAC,IAAI,CAAC,UAAU;gBACjB,CAAC,CAAC,KAAK,CAAC,IAAI,IAAI,KAAK,CAAC,IAAI;oBAC1B,CAAC,CAAC,KAAK;oBACP,CAAC,CAAC,CAAC,EAAE,CAAA;QAET,IAAI,UAAU,EAAE;YACd,KAAK,CAAC,UAAU,GAAG,IAAI,CAAA;SACxB;QAED,IAAI,CAAC,KAAK,GAAG,CAAC,CAAA;QACd,OAAO,GAAG,OAAO,GAAG,EAAE,CAAA;QACtB,MAAM,GAAG,GAAW,EAAE,EAAE,EAAE,OAAO,EAAE,KAAK,EAAE,CAAA;QAE1C,MAAM,EAAE,GAAG,IAAI,SAAS,CAAC,EAAE,EAAE,OAAO,EAAE,KAAK,CAAC,CAAA;QAE5C,6CAA6C;QAC7C,IAAI,KAAK,EAAE;YACT,EAAE,CAAC,OAAO,GAAG,EAAE,CAAC,OAAO,CAAC,OAAO,EAAE,GAAG,MAAM,CAAA;SAC3C;QAED,IACE,IAAI,CAAC,SAAS;YACd,IAAI,CAAC,SAAS,YAAY,MAAM;YAChC,IAAI,CAAC,SAAS,CAAC,SAAS,EACxB;YACA,KAAK,GAAG,IAAI,CAAA;SACb;QAED,IAAI,KAAK,EAAE;YACT,IAAI,KAAK,CAAC,cAAc,IAAI,KAAK,CAAC,cAAc,KAAK,EAAE,EAAE;gBACvD,IAAI,CAAC,eAAe,CAAC,EAAE,CAAC,CAAA;gBACxB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,cAAc,CAAC,CAAA;aACxC;YACD,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAA;YACxB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,IAAI,CAAC,EAAE,GAAG,EAAE,CAAC,OAAO,CAAC,CAAA;YACjD,IAAI,IAAI,CAAC,IAAI,IAAI,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE;gBAClD,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,YAAY,GAAG,OAAO,GAAG,IAAI,CAAC,CAAA;aACjD;SACF;aAAM;YACL,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,CAAA;YACnB,IAAI,IAAI,CAAC,IAAI,IAAI,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE;gBAClD,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,YAAY,GAAG,OAAO,GAAG,IAAI,CAAC,CAAA;aAC/C;SACF;QAED,IAAI,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC,KAAK,EAAE;YAChC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAA;SACpB;QAED,IAAI,CAAC,QAAQ,EAAE,CAAA;IACjB,CAAC;IAED,GAAG,CAAC,QAA0B;QAC5B,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAA;QACnB,OAAO,IAAI,CAAA;IACb,CAAC;IAED;;OAEG;IACH,eAAe,CAA6B,CAAI;QAC9C,oCAAoC;QACpC,qBAAqB;QACrB,MAAM,GAAG,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,GAAG,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,CAAA;QAC5C,oBAAoB;QACpB,MAAM,OAAO,GAAG,YAAY,GAAG,IAAI,CAAA;QACnC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,CAAA;IAC5B,CAAC;IACD,mCAAmC;IAEnC,uBAAuB;IAEvB;;;OAGG;IACH,MAAM,CACJ,OAA4B,EAC5B,EAAuB,EACvB,eAAwB,KAAK;QAE7B,MAAM,CAAC,GAAG,IAAI,MAAM,CAClB,OAAO,EACP,CAAC,CAAC,EAAE;YACF,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC,CAAA;YAC/B,IAAI,EAAE;gBAAE,EAAE,CAAC,CAAC,CAAC,CAAA;YACb,IAAI,CAAC,SAAS,GAAG,IAAI,CAAA;YACrB,IAAI,CAAC,QAAQ,EAAE,CAAA;QACjB,CAAC,EACD,YAAY,CACb,CAAA;QACD,6DAA6D;QAC7D,mEAAmE;QACnE,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,OAAO,EAAE;YAC7B,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAA;YAClB,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC,CAAA;SAC/B;aAAM;YACL,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAA;SACtB;QACD,IAAI,CAAC,QAAQ,EAAE,CAAA;QACf,OAAO,CAAC,CAAC,OAAO,CAAA;IAClB,CAAC;IAED,IAAI,CAAC,QAA0B;QAC7B,IAAI,IAAI,CAAC,eAAe,IAAI,QAAQ,KAAK,QAAQ,EAAE;YACjD,MAAM,IAAI,KAAK,CAAC,+CAA+C,CAAC,CAAA;SACjE;QACD,IAAI,CAAC,KAAK,CAAC,oBAAoB,EAAE,IAAI,CAAC,IAAI,EAAE,QAAQ,KAAK,QAAQ,CAAC,CAAA;QAClE,IAAI,IAAI,CAAC,KAAK,IAAI,QAAQ,KAAK,QAAQ,EAAE;YACvC,IAAI,CAAC,KAAK,CAAC,oCAAoC,CAAC,CAAA;YAChD,OAAM;SACP;QAED,gEAAgE;QAChE,MAAM,GAAG,GAAG,IAAI,CAAC,WAAW,CAAA;QAC5B,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,gBAAgB,EAAE;YACjC,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,CAAA;YACtB,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAA;YAC5B,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,SAAS,EAAE;gBACvC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;gBACpB,IAAI,CAAC,QAAQ,EAAE,CAAA;aAChB;iBAAM;gBACL,MAAM,GAAG,GAAG,GAAG,EAAE,CAAA;gBACjB,IAAI,SAAS,CAAC,GAAG,CAAC,EAAE;oBAClB,yDAAyD;oBACzD,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAA;iBACjB;aACF;SACF;QAED,+DAA+D;QAC/D,sDAAsD;QACtD,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,SAAS,EAAE;YACvC,IAAI,CAAC,KAAK,CAAC,oCAAoC,CAAC,CAAA;YAChD,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;gBACpB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC,CAAA;aACpC;YACD,IAAI,CAAC,UAAU,GAAG,IAAI,CAAA;YACtB,OAAO,IAAI,CAAC,QAAQ,EAAE,CAAA;SACvB;QAED,IAAI,QAAQ,KAAK,QAAQ,EAAE;YACzB,IAAI,IAAI,CAAC,cAAc,EAAE;gBACvB,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE;oBACxB,IAAI,CAAC,cAAc,GAAG,IAAI,CAAA;oBAC1B,MAAM,EAAE,GAAG,IAAI,KAAK,CAClB,yCAAyC,CAC1C,CAAA;oBACD,KAAK,CAAC,iBAAiB,CAAC,EAAE,EAAE,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,GAAG,CAAC,CAAA;oBAC5D,EAAE,CAAC,KAAK,GAAG;wBACT,IAAI,EAAE,IAAI,CAAC,IAAI;qBAChB,CAAA;oBACD,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,CAAA;iBACf;gBACD,OAAM;aACP;YACD,IAAI,CAAC,KAAK,CAAC,yBAAyB,CAAC,CAAA;YACrC,IAAI,CAAC,cAAc,GAAG,IAAI,CAAA;SAC3B;QAED,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,CAAA;QAC5B,IAAI,CAAC,KAAK,GAAG,IAAI,CAAA;QAEjB,IAAI,IAAI,CAAC,QAAQ,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE;YACjD,IAAI,CAAC,KAAK,CAAC,uBAAuB,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,CAAA;YAC1D,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE,EAAE,QAAQ,CAAC,CAAA;SACpC;QAED,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;QACpB,IAAI,CAAC,QAAQ,EAAE,CAAA;IACjB,CAAC;IAED,IAAI,QAAQ;QACV,MAAM,IAAI,GAAG,CACX,UAAU,CAAC,KAAK,CAAC;YACjB,GAAG;YACH,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CACxB,CAAC,IAAI,EAAE,CAAA;QACR,MAAM,CAAC,GAAa;YAClB,CAAC,IAAI,CAAC,MAAM;gBACV,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ;gBACtB,CAAC,CAAC,IAAI,KAAK,KAAK;oBAChB,CAAC,CAAC,KAAK;oBACP,CAAC,CAAC,QAAQ,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAC1C,CAAC,IAAI,EAAE;SACT,CAAA;QACD,0CAA0C;QAC1C,qBAAqB;QACrB,MAAM,MAAM,GAAG,CAAC,IAAI,CAAC,IAAI,IAAI,EAAE,CAAC,CAAC,IAAI,EAAE,CAAA;QACvC,oBAAoB;QACpB,IAAI,MAAM;YAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;QAC1B,OAAO,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;IACtB,CAAC;IAED,QAAQ;QACN,IAAI,IAAI,CAAC,WAAW,EAAE;YACpB,OAAO,IAAI,CAAC,KAAK,CAAC,uBAAuB,CAAC,CAAA;SAC3C;QACD,IAAI,CAAC,KAAK,CAAC,kBAAkB,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAA;QAC5D,IAAI,CAAC,WAAW,GAAG,IAAI,CAAA;QAEvB,OAAO,CAAC,IAAI,CAAC,SAAS,EAAE;YACtB,MAAM,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAA;YAC5B,IAAI,CAAC,CAAC,EAAE;gBACN,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,CAAA;gBAC5B,MAAK;aACN;YACD,IAAI,CAAC,YAAY,IAAI,EAAE;gBACrB,IAAI,CAAC,KAAK,CAAC,oBAAoB,EAAE,CAAC,CAAC,IAAI,CAAC,CAAA;gBACxC,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,CAAA;aACxB;iBAAM,IAAI,CAAC,KAAK,GAAG,EAAE;gBACpB,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE,IAAI,CAAC,IAAI,CAAC,CAAA;gBAC/B,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE;oBACtB,IAAI,CAAC,YAAY,GAAG,IAAI,CAAA;oBACxB,wCAAwC;oBACxC,IAAI,CAAC,KAAK,CAAC,YAAY,EAAE,IAAI,CAAC,IAAI,CAAC,CAAA;oBACnC,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,EAAE,CAAA;oBAC3B,IAAI,SAAS,CAAC,MAAM,CAAC,EAAE;wBACrB,IAAI,CAAC,KAAK,CAAC,kBAAkB,CAAC,CAAA;wBAC9B,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,CAAC,EAAE;4BACtB,IAAI,CAAC,CAAC,QAAQ,EAAE;gCACd,kDAAkD;gCAClD,IAAI,CAAC,KAAK,CAAC,eAAe,EAAE,CAAC,CAAC,KAAK,CAAC,CAAA;gCACpC,IAAI,CAAC,OAAO,CAAC,0BAA0B,CAAC,CAAA;gCACxC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAA;6BACpB;4BACD,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;4BACpB,IAAI,CAAC,QAAQ,EAAE,CAAA;wBACjB,CAAC,CAAC,CAAA;wBACF,MAAK;qBACN;iBACF;gBACD,IAAI,CAAC,KAAK,CAAC,gBAAgB,EAAE,IAAI,CAAC,IAAI,CAAC,CAAA;gBACvC,IAAI,CAAC,MAAM,CAAC,GAAG,EAAE,CAAA;aAClB;iBAAM,IAAI,CAAC,YAAY,SAAS,EAAE;gBACjC,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,CAAA;gBAC1B,IAAI,CAAC,CAAC,KAAK,CAAC,cAAc,IAAI,CAAC,CAAC,KAAK,CAAC,cAAc,KAAK,EAAE,EAAE;oBAC3D,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,CAAA;oBACvB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,cAAc,CAAC,CAAA;iBAC1C;gBACD,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC,GAAG,CAAC,CAAA;gBACvB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,GAAG,EAAE,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC,OAAO,CAAC,CAAA;aAChD;iBAAM,IAAI,OAAO,CAAC,KAAK,QAAQ,EAAE;gBAChC,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,CAAA;gBACvB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA;aACrB;iBAAM,IAAI,CAAC,YAAY,MAAM,EAAE;gBAC9B,CAAC,CAAC,KAAK,GAAG,IAAI,CAAA;gBACd,IAAI,CAAC,SAAS,GAAG,CAAC,CAAA;gBAClB,CAAC,CAAC,MAAM,EAAE,CAAA;aACX;iBAAM,IAAI,OAAO,CAAC,KAAK,UAAU,EAAE;gBAClC,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,CAAA;gBACzB,MAAM,GAAG,GAAG,CAAC,EAAE,CAAA;gBACf,IAAI,SAAS,CAAC,GAAG,CAAC,EAAE;oBAClB,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAA;iBACjB;aACF;iBAAM,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE;gBAC3B,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,CAAA;gBACvB,MAAM,CAAC,GAAG,CAAC,CAAC,KAAK,EAAgB,CAAA;gBACjC,MAAM,EAAE,GAAG,CAAC,CAAC,KAAK,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAEtC,CAAA;gBACR,IAAI,OAAO,EAAE,KAAK,UAAU,EAAE;oBAC5B,IAAI,CAAC,KAAK,CACR,sCAAsC,EACtC,CAAC,EACD,OAAO,IAAI,CAAC,CAAC,CAAC,CACf,CAAA;oBACD,SAAQ;iBACT;gBACD,MAAM,GAAG,GAAG,EAAE,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC,CAAA;gBAC/B,IAAI,SAAS,CAAC,GAAG,CAAC,EAAE;oBAClB,mBAAmB;oBACnB,GAAG,CAAC,IAAI,CACN,GAAG,EAAE;wBACH,IAAI,CAAC,WAAW,GAAG,KAAK,CAAA;wBACxB,IAAI,CAAC,QAAQ,EAAE,CAAA;oBACjB,CAAC,EACD,CAAC,EAAW,EAAE,EAAE;wBACd,IAAI,CAAC,WAAW,GAAG,KAAK,CAAA;wBACxB,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,CAAA;oBAChB,CAAC,CACF,CAAA;oBACD,OAAM;iBACP;gBACD,qBAAqB;aACtB;iBAAM;gBACL,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAA;aAChD;YACD,oBAAoB;SACrB;QAED,OAAO,CAAC,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,EAAE;YACtD,MAAM,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAA;YAC/B,IAAI,CAAC,CAAC,EAAE;gBACN,MAAK;aACN;YAED,IAAI,CAAC,CAAC,CAAC,QAAQ,EAAE;gBACf,IAAI,CAAC,WAAW,GAAG,IAAI,CAAA;gBACvB,MAAK;aACN;YAED,IAAI,CAAC,KAAK,CAAC,eAAe,EAAE,CAAC,CAAC,CAAA;YAC9B,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,CAAC,CAAC,CAAA;YAC5B,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAA;YAChB,IAAI,IAAI,CAAC,SAAS,EAAE;gBAClB,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,CAAA;aACvB;iBAAM;gBACL,CAAC,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAA;aACxC;SACF;QAED,IAAI,CAAC,KAAK,CAAC,iBAAiB,EAAE,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,SAAS,CAAC,CAAA;QACzD,IAAI,CAAC,WAAW,GAAG,KAAK,CAAA;QAExB,6DAA6D;QAC7D,8CAA8C;QAC9C,IAAI,CAAC,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;YACxC,IAAI,CAAC,QAAQ,EAAE,CAAA;SAChB;aAAM,IAAI,IAAI,CAAC,IAAI,EAAE;YACpB,iEAAiE;YACjE,qBAAqB;YACrB,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;SAClB;IACH,CAAC;IAED,IAAI,IAAI;QACN,OAAO,CACL,CAAC,IAAI,CAAC,WAAW;YACjB,UAAU,CAAC,IAAI,CAAC;YAChB,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI;YACf,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM;YACrB,CAAC,IAAI,CAAC,SAAS;YACf,+DAA+D;YAC/D,IAAI,CAAC,QAAQ,KAAK,CAAC,CAAC,CACrB,CAAA;IACH,CAAC;IAED,cAAc,CAAiB,CAAI;QACjC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,WAAW,CAAC,SAAS,CAAC,MAAM,CAAA;QACzC,CAAC,CAAC,OAAO,GAAG,CAAC,CAAC,OAAO,IAAI,IAAI,YAAY,CAAC,IAAI,EAAE,CAAC,CAAC,MAAM,CAAC,CAAA;QACzD,CAAC,CAAC,cAAc,GAAG,IAAI,CAAA;QACvB,MAAM,EAAE,GAAG,CAAC,CAAC,OAAO,CAAC,OAAO,CAAA;QAC5B,MAAM,GAAG,GACP,EAAE,IAAI,CAAC,CAAC,OAAO,EAAE;YACf,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC,KAAK,CAAC,GAAG,GAAG;YACzC,CAAC,CAAC,IAAI,CAAA;QACV,IAAI,GAAG,IAAI,EAAE,IAAI,GAAG,GAAG,EAAE,EAAE;YACzB,CAAC,CAAC,OAAO,EAAE,CAAA;SACZ;aAAM;YACL,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAA;SAChB;QACD,IAAI,CAAC,KAAK,CACR,mBAAmB,EACnB,IAAI,CAAC,IAAI,EACT,CAAC,CAAC,IAAI,EACN,CAAC,CAAC,OAAO,CAAC,OAAO,CAClB,CAAA;QACD,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAA;QACnB,CAAC,CAAC,OAAO,CAAC,cAAc,GAAG,CAAC,CAAC,MAAM,IAAI,EAAE,CAAA;QACzC,CAAC,CAAC,OAAO,CAAC,KAAK,GAAG,EAAE,CAAA;QACpB,IAAI,CAAC,CAAC,IAAI;YAAE,CAAC,CAAC,OAAO,CAAC,IAAI,GAAG,CAAC,CAAC,IAAI,CAAA;QACnC,IAAI,IAAI,CAAC,SAAS,KAAK,CAAC;YAAE,IAAI,CAAC,SAAS,GAAG,IAAI,CAAA;QAC/C,CAAC,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,CAAA;QAC9B,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE,CAAC,CAAC,CAAA;QAC1B,IAAI,CAAC,QAAQ,EAAE,CAAA;IACjB,CAAC;IAED,cAAc,CAAiB,CAAI;QACjC,IAAI,CAAC,KAAK,CAAC,eAAe,EAAE,CAAC,CAAC,IAAI,CAAC,CAAA;QACnC,IAAI,CAAC,IAAI,CAAC,gBAAgB,EAAE,CAAC,CAAC,CAAA;QAC9B,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,WAAW,CAAC,SAAS,CAAC,MAAM,CAAA;QACzC,qEAAqE;QACrE,qBAAqB;QACrB,CAAC,CAAC,OAAO,GAAG,CAAC,CAAC,OAAO,IAAI,IAAI,YAAY,CAAC,IAAI,EAAE,CAAC,CAAC,MAAM,CAAC,CAAA;QACzD,oBAAoB;QACpB,IAAI,CAAC,WAAW,GAAG,KAAK,CAAA;QACxB,MAAM,GAAG,GAAG,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,CAAA;QACpC,IAAI,GAAG,KAAK,CAAC,CAAC;YAAE,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC,CAAA;QAC5C,CAAC,CAAC,cAAc,GAAG,IAAI,CAAA;QACvB,CAAC,CAAC,OAAO,CAAC,IAAI,GAAG,CAAC,CAAC,IAAI,CAAA;QACvB,MAAM,EAAE,GAAG,CAAC,CAAC,OAAO,CAAC,OAAO,CAAA;QAC5B,MAAM,GAAG,GAAG,EAAE,IAAI,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAA;QAChE,IAAI,GAAG,IAAI,EAAE,IAAI,GAAG,GAAG,EAAE,EAAE;YACzB,CAAC,CAAC,OAAO,EAAE,CAAA;SACZ;aAAM;YACL,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAA;SAChB;QACD,IAAI,CAAC,KAAK,CAAC,uBAAuB,EAAE,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,CAAC,CAAA;QACtD,IAAI,CAAC,SAAS,GAAG,IAAI,CAAA;QACrB,IAAI,CAAC,KAAK,CAAC,2BAA2B,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,CAAA;QAC9D,CAAC,CAAC,OAAO,CAAC,KAAK,GAAG,EAAE,CAAA;QAEpB,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,OAAO,EAAE,IAAI,CAAC,CAAA;QAEtD,IAAI,CAAC,KAAK,CAAC,4BAA4B,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,CAAA;QAC/D,CAAC,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,CAAA;QAC9B,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE,CAAC,CAAC,CAAA;QAC1B,IAAI,CAAC,QAAQ,EAAE,CAAA;IACjB,CAAC;IAED;;OAEG;IACH,IAAI,CAAC,EAAc;QACjB,IAAI,OAAO,IAAI,CAAC,OAAO,CAAC,OAAO,KAAK,QAAQ,EAAE;YAC5C,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAA;SACtC;QACD,IAAI,CAAC,KAAK,CAAC,UAAU,EAAE,IAAI,CAAC,IAAI,CAAC,CAAA;QAEjC,MAAM,GAAG,GAAG,GAAG,EAAE;YACf,IAAI,CAAC,KAAK,CAAC,6BAA6B,CAAC,CAAA;YACzC,IAAI,CAAC,aAAa,GAAG,IAAI,CAAA;YACzB,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAA;YACnB,IAAI,EAAE,CAAA;QACR,CAAC,CAAA;QAED,MAAM,IAAI,GAAG,CAAC,EAAU,EAAE,EAAE;YAC1B,IAAI,EAAE;gBAAE,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,CAAA;YAEtB,IAAI,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,SAAS;gBAAE,EAAE,EAAE,CAAA;;gBACnC,IAAI,CAAC,MAAM,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE,CAAA;QAC/B,CAAC,CAAA;QAED,mEAAmE;QACnE,oEAAoE;QACpE,oEAAoE;QACpE,0DAA0D;QAC1D,MAAM,GAAG,GAAG,CAAC,GAAG,EAAE;YAChB,IAAI,CAAC,IAAI,CAAC,EAAE;gBAAE,OAAM;YACpB,IAAI;gBACF,OAAO,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,IAAI,IAAI,CAAC,CAAA;aAC/B;YAAC,OAAO,EAAO,EAAE;gBAChB,IAAI,CAAC,EAAE,IAAI,OAAO,EAAE,KAAK,QAAQ,EAAE;oBACjC,EAAE,GAAG,EAAE,KAAK,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,EAAE,CAAA;iBAC7B;gBACD,EAAE,CAAC,SAAS,GAAG,mBAAmB,CAAA;gBAClC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,CAAA;aACf;QACH,CAAC,CAAC,EAAE,CAAA;QAEJ,IAAI,GAAG,IAAI,GAAG,CAAC,IAAI,EAAE;YACnB,IAAI,CAAC,WAAW,GAAG,GAAG,CAAA;YACtB,GAAG,CAAC,eAAe,GAAG,IAAI,CAAA;YAC1B,GAAG,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,EAAO,EAAE,EAAE;gBACxB,IAAI,CAAC,EAAE,IAAI,OAAO,EAAE,KAAK,QAAQ,EAAE;oBACjC,EAAE,GAAG,EAAE,KAAK,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,EAAE,CAAA;iBAC7B;gBACD,EAAE,CAAC,SAAS,GAAG,0BAA0B,CAAA;gBACzC,IAAI,CAAC,EAAE,CAAC,CAAA;YACV,CAAC,CAAC,CAAA;SACH;;YAAM,IAAI,EAAE,CAAA;QAEb,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,IAAI,CAAC,IAAI,CAAC,CAAA;IACpC,CAAC;IAED,eAAe,CAAiB,CAAI;QAClC,IAAI,CAAC,KAAK,CAAC,gBAAgB,EAAE,CAAC,CAAC,IAAI,CAAC,CAAA;QACpC,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,CAAA;QACxB,IAAI,CAAC,SAAS,GAAG,CAAC,CAAA;QAClB,IAAI,CAAC,CAAC,CAAC,QAAQ,EAAE;YACf,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,CAAC,CAAC,CAAA;YAC5B,IAAI,CAAC,KAAK,CAAC,qBAAqB,CAAC,CAAA;YACjC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE,GAAG,EAAE,KAAK,EAAE,CAAC,CAAA;YACnC,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,CAAA;YACvB,IAAI,CAAC,KAAK,CAAC,iBAAiB,EAAE,CAAC,CAAC,IAAI,CAAC,CAAA;YACrC,CAAC,CAAC,OAAO,CAAC,GAAG,EAAE;gBACb,IAAI,CAAC,KAAK,CAAC,kBAAkB,EAAE,CAAC,CAAC,IAAI,CAAC,CAAA;gBACtC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,CAAA;YACxB,CAAC,CAAC,CAAA;SACH;aAAM,IAAI,CAAC,CAAC,cAAc,EAAE;YAC3B,IAAI,CAAC,IAAI,CAAC,gBAAgB,EAAE,CAAC,CAAC,CAAA;YAC9B,IAAI,CAAC,KAAK,CAAC,+BAA+B,CAAC,CAAA;YAC3C,2BAA2B;YAC3B,IAAI,CAAC,SAAS,GAAG,IAAI,CAAA;YACrB,IAAI,CAAC,CAAC,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC,MAAM,EAAE;gBAC7B,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,OAAO,EAAE,IAAI,CAAC,CAAA;aACvD;SACF;aAAM;YACL,IAAI,CAAC,SAAS,GAAG,CAAC,CAAA;YAClB,IAAI,CAAC,KAAK,CAAC,iCAAiC,EAAE,CAAC,CAAC,CAAA;YAChD,4BAA4B;YAC5B,0CAA0C;YAC1C,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAA;SACtB;IACH,CAAC;IAED;;;OAGG;IACH,SAAS,CACP,KAAgE;QAEhE,MAAM,MAAM,GAAG,CAAC,KAAK,EAAE,SAAS,IAAI,OAAO,CAAC,KAAK,CAAa,CAAA;QAC9D,qBAAqB;QACrB,IAAI,CAAC,MAAM,EAAE;YACX,MAAM,IAAI,KAAK,CAAC,wCAAwC,CAAC,CAAA;SAC1D;QACD,oBAAoB;QAEpB,IACE,IAAI,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC;YACvB,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,OAAO;YACzB,IAAI,CAAC,WAAW;YAChB,IAAI,CAAC,OAAO;YACZ,IAAI,CAAC,SAAS;YACd,IAAI,CAAC,IAAI,CAAC,IAAI;YACd,IAAI,CAAC,QAAQ,CAAC,MAAM,EACpB;YACA,MAAM,IAAI,KAAK,CAAC,4CAA4C,CAAC,CAAA;SAC9D;QAED,IAAI,CAAC,eAAe,GAAG,IAAI,CAAA;QAC3B,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAA;QACrB,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,CAAC,EAAE;YAC1B,oDAAoD;YACpD,CAAC,CAAC,IAAI,GAAG,CAAC,CAAA;YACV,MAAM,CAAC,GAAG,IAAI,IAAI,CAAC;gBACjB,IAAI,EAAE,CAAC,CAAC,IAAI;gBACZ,MAAM,EAAE,IAAI;gBACZ,MAAM,EAAE,CAAC;gBACT,IAAI,EAAE,CAAC,CAAC,IAAI;gBACZ,MAAM,EAAE,CAAC,CAAC,MAAM;gBAChB,WAAW,EAAE,CAAC,CAAC,WAAW;gBAC1B,kBAAkB,EAAE,CAAC,CAAC,kBAAkB;gBACxC,OAAO,EAAE,IAAI,CAAC,YAAY,EAAE;aAC7B,CAAC,CAAA;YACF,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE,CAAC,CAAC,CAAA;YAC1B,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,CAAC,CAAC,CAAA;YAC5B,IAAI,CAAC,IAAI,CAAC,gBAAgB,EAAE,CAAC,CAAC,CAAA;YAC9B,CAAC,CAAC,EAAE,CAAC,UAAU,EAAE,GAAG,EAAE;gBACpB,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC,IAAI,CAAA;gBACf,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE,CAAC,CAAC,CAAA;YAC5B,CAAC,CAAC,CAAA;QACJ,CAAC,CAAC,CAAA;QACF,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;QACxB,MAAM,CAAC,MAAM,EAAE,CAAA;IACjB,CAAC;IAED;;;;;OAKG;IACH,GAAG,CACD,KAA8B,EAC9B,QAAgD,EAAE,EAClD,MAAgC;QAEhC,IAAI,IAAI,CAAC,SAAS,EAAE;YAClB,OAAO,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;gBAC1C,OAAO,EAAE,IAAI;aACd,CAAC,CAAA;SACH;QAED,IAAI,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,KAAK,EAAE;YAC9B,MAAM,EAAE,GAAG,IAAI,KAAK,CAClB,8CAA8C,CAC/C,CAAA;YACD,KAAK,CAAC,iBAAiB,CAAC,EAAE,EAAE,MAAM,CAAC,CAAA;YACnC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,CAAA;YACd,OAAO,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;gBAC1C,OAAO,EAAE,IAAI;aACd,CAAC,CAAA;SACH;QAED,KAAK,CAAC,OAAO,GAAG,IAAI,CAAC,YAAY,EAAE,CAAA;QACnC,IAAI,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,EAAE;YAC/B,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,IAAI,EAAE,EAAE,KAAK,CAAC,CAAA;YAClC,OAAO,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;gBAC1C,OAAO,EAAE,IAAI;aACd,CAAC,CAAA;SACH;QAED,KAAK,CAAC,MAAM,GAAG,MAAM,CAAA;QACrB,IAAI,KAAK,CAAC,QAAQ,KAAK,SAAS,EAAE;YAChC,IAAI,IAAI,CAAC,IAAI,GAAG,CAAC,EAAE;gBACjB,KAAK,CAAC,QAAQ,GAAG,IAAI,CAAA;aACtB;iBAAM;gBACL,KAAK,CAAC,QAAQ,GAAG,KAAK,CAAA;aACvB;SACF;QAED,KAAK,CAAC,IAAI,GAAG,KAAK,CAAC,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAA;QAC9D,KAAK,CAAC,MAAM,GAAG,IAAI,CAAA;QACnB,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,KAAK,CAAC,EAAE,KAAK,IAAI,EAAE;YAClC,MAAM,EAAE,GAAG,KAAK,CAAC,OAAO,CAAC,EAAE,EAAE,MAAM,CAAC,CAAA;YACpC,KAAK,CAAC,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC,CAAA;YAChB,KAAK,CAAC,KAAK,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;SAChD;QACD,KAAK,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAA;QAE5B,MAAM,CAAC,GAAG,IAAI,KAAK,CAAC,KAAU,CAAC,CAAA;QAC/B,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA;QAClB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA;QACrB,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE,CAAC,CAAC,CAAA;QAE1B,MAAM,CAAC,GAAG,IAAI,QAAQ,EAAgB,CAAA;QACtC,CAAC,CAAC,QAAQ,GAAG,CAAC,CAAA;QACd,IAAI,CAAC,QAAQ,EAAE,CAAA;QACf,OAAO,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,EAAE,EAAE,OAAO,EAAE,CAAC,EAAE,CAAC,CAAA;IACjD,CAAC;IAED,KAAK,CACH,EAAO,EACP,KAAa,EACb,QAAiB,KAAK;QAEtB,IAAI,CAAC,KAAK,CAAC,gBAAgB,EAAE,IAAI,CAAC,IAAI,EAAE,EAAE,CAAC,OAAO,CAAC,CAAA;QACnD,kEAAkE;QAClE,uDAAuD;QACvD,IAAI,IAAI,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;YAChC,IAAI,CAAC,EAAE,GAAG,GAAG,EAAE;gBACb,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,CAAA;gBACd,IAAI,CAAC,GAAG,EAAE,CAAA;YACZ,CAAC,CAAA;YACD,OAAM;SACP;QAED,oDAAoD;QACpD,yDAAyD;QACzD,IAAI,CAAC,EAAE,IAAI,OAAO,EAAE,KAAK,QAAQ,EAAE;YACjC,EAAE,GAAG,EAAE,KAAK,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,EAAE,CAAA;SAC7B;QAED,IAAI,IAAI,CAAC,IAAI,IAAI,CAAC,KAAK,EAAE;YACvB,EAAE,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAA;SACpB;QACD,IAAI,CAAC,KAAK,EAAE;YACV,KAAK,GAAG,cAAc,CAAC,EAAE,EAAE,KAAK,CAAC,CAAA;SAClC;QACD,IAAI,CAAC,KAAK,CAAC,qBAAqB,EAAE,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAA;QACnD,MAAM,KAAK,GACT,CAAC,CAAC,IAAI,CAAC,OAAO;YACd,yDAAyD;YACzD,qBAAqB;YACrB,CAAC,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,KAAK,KAAK,IAAI,CAAC,QAAQ,CAAC,CAAA;QACtD,oBAAoB;QACpB,IAAI,CAAC,MAAM,CAAC,EAAE,GAAG,KAAK,CAAA;QACtB,KAAK,CAAC,KAAK,CAAC,EAAE,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,CAAA;QAEpC,yDAAyD;QACzD,4DAA4D;QAC5D,wDAAwD;QACxD,yDAAyD;QACzD,YAAY;QACZ,IAAI,CAAC,KAAK,EAAE;YACV,MAAM,GAAG,GACP,OAAO,KAAK,EAAE,OAAO,KAAK,QAAQ;gBAChC,CAAC,CAAC,KAAK,CAAC,OAAO;gBACf,CAAC,CAAC,OAAO,EAAE,CAAC,OAAO,KAAK,QAAQ;oBAChC,CAAC,CAAC,EAAE,CAAC,OAAO;oBACZ,CAAC,CAAC,EAAE,CAAC,KAAK;wBACV,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;wBACzB,CAAC,CAAC,OAAO,EAAE,CAAC,KAAK,KAAK,QAAQ;4BAC9B,CAAC,CAAC,EAAE,CAAC,KAAK;4BACV,CAAC,CAAC,EAAE,CAAA;YACR,KAAK,KAAK,EAAE,EAAE,EAAE,IAAI,EAAE,CAAA;YACtB,IAAI,GAAG,KAAK,EAAE;gBAAE,KAAK,CAAC,EAAE,GAAG,IAAI,CAAA;YAC/B,IAAI,EAAE,CAAC,KAAK,EAAE;gBACZ,MAAM,CAAC,GAAG,KAAK,CAAC,UAAU,CAAC,EAAE,CAAC,KAAK,CAAC,CAAA;gBACpC,KAAK,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,CAAA;gBACf,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAA;aACpD;YACD,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,KAAK,CAAC,CAAA;YACrB,IAAI,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,UAAU,EAAE;gBACjC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAA;gBAClB,IAAI,CAAC,UAAU,GAAG,KAAK,CAAA;gBACvB,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAA;aACnB;SACF;QACD,IAAI,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,SAAS,YAAY,MAAM,EAAE;YACtD,IAAI,CAAC,SAAS,CAAC,KAAK,CAClB,MAAM,CAAC,MAAM,CACX,IAAI,KAAK,CAAC,qCAAqC,CAAC,EAChD,EAAE,MAAM,EAAE,EAAE,EAAE,CACf,CACF,CAAA;YACD,IAAI,CAAC,SAAS,GAAG,IAAI,CAAA;SACtB;QACD,IAAI,CAAC,KAAK,EAAE;YACV,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAA;YACnB,IAAI,CAAC,WAAW,GAAG,KAAK,CAAA;SACzB;QAED,IAAI,CAAC,QAAQ,EAAE,CAAA;IACjB,CAAC;IAED,MAAM,CAAC,OAAgB;QACrB,KAAK,CAAC,MAAM,CAAC,OAAO,CAAC,CAAA;QACrB,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAA;QACnB,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;YAChB,IAAI,CAAC,MAAM,EAAE,CAAA;SACd;IACH,CAAC;IAED,MAAM,CAAC,MAAe,KAAK;QACzB,IAAI,IAAI,CAAC,SAAS;YAAE,OAAM;QAE1B,8DAA8D;QAC9D,8DAA8D;QAC9D,8DAA8D;QAC9D,gEAAgE;QAChE,IAAI,CAAC,WAAW,GAAG,IAAI,CAAA;QACvB,IAAI,IAAI,CAAC,SAAS,EAAE;YAClB,MAAM,CAAC,GAAG,IAAI,CAAC,SAAS,CAAA;YACxB,IAAI,CAAC,YAAY,MAAM;gBAAE,CAAC,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,iBAAiB,CAAC,CAAC,CAAA;iBACzD,IAAI,OAAQ,CAAc,CAAC,MAAM,KAAK,UAAU;gBAClD,CAAc,CAAC,MAAM,CAAC,IAAI,CAAC,CAAA;;gBACzB,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,iBAAiB,CAAC,CAAA;YACtC,IAAI,CAAC,SAAS,GAAG,IAAI,CAAA;SACtB;aAAM,IAAI,GAAG,EAAE;YACd,IAAI,CAAC,QAAQ,EAAE,CAAA;YACf,IAAI,UAAU,CAAC,IAAI,CAAC,EAAE;gBACpB,MAAM,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,OAAO,CAAC,CAAA;gBAC/C,OAAO,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAA;gBACxB,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE,OAAO,CAAC,CAAA;aACtC;SACF;QAED,IAAI,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,WAAW,CAAC,eAAe;YACtD,IAAI,CAAC,WAAW,CAAC,eAAe,EAAE,CAAA;QAEpC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAC1C,MAAM,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA;YACvB,IAAI,CAAC,YAAY,IAAI,IAAI,CAAC,CAAC,CAAC,cAAc,EAAE;gBAC1C,MAAM,GAAG,GAAG,6BAA6B,CAAC,CAAC,IAAI,EAAE,CAAA;gBACjD,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI,SAAS,CAAC,KAAK,EAAE,GAAG,EAAE,CAAC,CAAC,OAAO,CAAC,CAAA;gBACpD,IAAI,CAAC,KAAK,EAAE,CAAA;aACb;SACF;QAED,IAAI,CAAC,WAAW,GAAG,KAAK,CAAA;QACxB,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAA;IACrB,CAAC;IAED;;;OAGG;IACH,eAAe,CACb,KAAyC;QAEzC,OAAO,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,IAAI,KAAK,CAAC,IAAI,CAAC,CAAA;IACrC,CAAC;CACF","sourcesContent":["// lifecycle methods like beforeEach, afterEach, teardown\n// defined in plugins/lifecycle.ts\n\nimport * as stack from '@tapjs/stack'\nimport type { Test, TestOpts } from '@tapjs/test'\nimport { Minipass } from 'minipass'\nimport assert from 'node:assert'\nimport { relative } from 'node:path'\nimport { hrtime } from 'node:process'\nimport { Readable } from 'node:stream'\nimport { format } from 'node:util'\nimport { FinalResults } from 'tap-parser'\nimport { Deferred } from 'trivial-deferred'\nimport { Base, BaseOpts } from './base.js'\nimport { esc } from './esc.js'\nimport { extraFromError } from './extra-from-error.js'\nimport { mainScript } from './main-script.js'\nimport { argv, cwd } from './proc.js'\nimport { Spawn } from './spawn.js'\nimport { Stdin } from './stdin.js'\nimport { Result, TestPoint } from './test-point.js'\nimport { Waiter } from './waiter.js'\nimport { Worker } from './worker.js'\n\nimport { IMPLICIT } from './implicit-end-sigil.js'\nimport { Extra, MessageExtra, TapBaseEvents } from './index.js'\nimport { normalizeMessageExtra } from './normalize-message-extra.js'\n\nconst VERSION = 'TAP version 14\\n'\n\nexport interface TestBaseOpts extends BaseOpts {\n  /**\n   * The number of jobs to run in parallel. Defaults to 1\n   */\n  jobs?: number\n\n  /**\n   * Test function called when this Test is executed\n   * This is usually not set on the extra object, but as an argument to\n   * the `t.test(..)` method, just defined here so TS doesn't complain\n   * when we reference it in the various flow control machinery.\n   *\n   * @internal\n   */\n  cb?: (...args: any[]) => any\n}\n\nconst queueEmpty = <T extends TestBase>(t: T) =>\n  t.queue.length === 0 ||\n  (t.queue.length === 1 && t.queue[0] === VERSION)\n\nexport type TapPlugin<\n  B extends Object,\n  O extends TestBaseOpts | any = unknown\n> = unknown extends O\n  ? (t: TestBase) => B\n  : (t: TestBase, opts: O) => B\n\n/**\n * Sigil to put in the queue to signal the end of all things\n */\nconst EOF = Symbol('EOF')\n\nexport type { EOF }\n\nexport type QueueEntry =\n  | string\n  | TestPoint\n  | Base\n  | typeof EOF\n  | Waiter\n  | [method: string, ...args: any[]]\n  | (() => any)\n\nconst isPromise = (p: any): p is Promise<any | void> =>\n  !!p && typeof p === 'object' && typeof p.then === 'function'\n\n/**\n * the promise returned by t.test(), t.spawn(), etc.\n * If a subtest was not created (because of being marked skipped,\n * the parent having bailed out, etc.) then the `subtest` field\n * will be set to `null`.\n */\nexport interface PromiseWithSubtest<S extends Base>\n  extends Promise<FinalResults | null> {\n  subtest: S | null\n}\n\nexport interface TestBaseEvents extends TapBaseEvents {\n  subtestStart: [p: Base]\n  idle: []\n  subtestEnd: [p: Base]\n  subtestProcess: [p: Base]\n  subtestAdd: [p: Base]\n  result: [res: Result]\n  stdin: [s: Stdin]\n  spawn: [s: Spawn]\n  worker: [w: Worker]\n}\n\n/**\n * The TestBaseBase class is the base class for all plugins,\n * and eventually thus the Test class.\n *\n * This implements subtest functionality, TAP stream generation,\n * lifecycle events, and only the most basic pass/fail assertions.\n *\n * All other features are added with plugins.\n */\nexport class TestBase extends Base<TestBaseEvents> {\n  // NB: generated pluginified Test class needs to declare over this\n  declare parent?: TestBase\n  declare options: TestBaseOpts\n\n  /**\n   * Attached when the Test class is instantiated from a TestBase,\n   * as a reference to the final plugged-in Test instance.\n   * If TestBase is used directly (outside the context of a plugin)\n   * or during plugin setup time, this will be undefined, so watch out.\n   */\n  t!: Test\n\n  donePromise?: Promise<any> & {\n    tapAbortPromise?: () => void\n  }\n  jobs: number\n  subtests: Base[] = []\n  pool: Set<Base> = new Set()\n  queue: QueueEntry[] = [VERSION]\n  cb?: (...args: any[]) => any\n  count: number = 0\n  ended: boolean = false\n  diagnostic: null | boolean = null\n\n  #planEnd: number = -1\n  #printedResult: boolean = false\n  #explicitEnded: boolean = false\n  #explicitPlan: boolean = false\n  #promiseEnded: boolean = false\n  #multiEndThrew: boolean = false\n  #n: number = 0\n  #noparallel: boolean = false\n  #occupied: null | Waiter | Base = null\n  #pushedEnd: boolean = false\n  #pushedBeforeEnd: boolean = false\n  #nextChildId: number = 1\n  #currentAssert: null | Function | ((..._: any) => any) = null\n  #processing: boolean = false\n  #doingStdinOnly: boolean = false\n  #calledOnEOF: boolean = false\n\n  /**\n   * true if the test has printed at least one TestPoint\n   */\n  get printedResult(): boolean {\n    return this.#printedResult\n  }\n\n  /**\n   * true if the test is currently waiting for something to finish\n   */\n  get occupied(): boolean {\n    return !!this.#occupied\n  }\n\n  constructor(options: TestBaseOpts) {\n    super(options)\n\n    this.jobs = (options.jobs && Math.max(options.jobs, 1)) || 1\n\n    if (typeof options.diagnostic === 'boolean') {\n      this.diagnostic = options.diagnostic\n    }\n\n    if (options.cb) {\n      this.#setCB(options.cb)\n    }\n  }\n\n  #setCB<T extends TestBase>(this: T, cb: (t: T) => any) {\n    this.cb = (...args: any[]) =>\n      this.hook.runInAsyncScope(cb, this.t || this, ...args)\n  }\n\n  // TAP output generating methods\n  /**\n   * immediately exit this and all parent tests with a TAP\n   * Bail out! message.\n   */\n  bailout(message?: string) {\n    if (this.parent && (this.results || this.ended)) {\n      this.parent.bailout(message)\n    } else {\n      this.#process()\n      message = message ? ' ' + ('' + esc(message)).trim() : ''\n      message = message.replace(/[\\r\\n]/g, ' ')\n      this.parser.write('Bail out!' + message + '\\n')\n    }\n    this.#end(IMPLICIT)\n    this.#process()\n  }\n\n  /**\n   * output a TAP comment, formatted like console.log()\n   */\n  comment(...args: any[]) {\n    const body = format(...args)\n    const message =\n      ('# ' + body.split(/\\r?\\n/).join('\\n# ')).trim() + '\\n'\n\n    if (this.results || this.ended || this.#pushedEnd) {\n      // the fallback to console.log is a bit weird,\n      // but the only alternative seems to be to just lose it.\n      if (this.parent) this.parent.comment(...args)\n      else console.log(message.trimEnd())\n    } else if (this.#occupied) {\n      this.queue.push(message)\n      this.#process()\n    } else {\n      this.write(message)\n    }\n  }\n\n  /**\n   * Called when the test times out.\n   * Options are passed as diagnostics to the threw() method\n   */\n  timeout(\n    options: Extra & { expired?: string } = { expired: this.name }\n  ) {\n    options.expired = options.expired || this.name\n    if (this.#occupied && this.#occupied instanceof Base) {\n      this.#occupied.timeout(options)\n    } else {\n      super.timeout(options)\n    }\n    this.#end(IMPLICIT)\n  }\n\n  /**\n   * Set TAP pragma configs to affect the behavior of the parser.\n   * Only `strict` is supported by the parser.\n   */\n  pragma(set: { [k: string]: boolean }) {\n    const p = Object.keys(set).reduce(\n      (acc, i) => acc + 'pragma ' + (set[i] ? '+' : '-') + i + '\\n',\n      ''\n    )\n    this.queue.push(p)\n    this.#process()\n  }\n\n  /**\n   * Specify the number of Test Points expected by this test.\n   * Outputs a TAP plan line.\n   */\n  plan(n: number, comment?: string): void\n  plan(n: number, comment: string, implicit: typeof IMPLICIT): void\n  plan(n: number, comment?: string, implicit?: typeof IMPLICIT) {\n    if (this.bailedOut) {\n      return\n    }\n\n    if (this.#explicitPlan) {\n      throw new Error('Cannot set plan more than once')\n    }\n    this.#explicitPlan = implicit !== IMPLICIT\n\n    if (this.#planEnd !== -1) {\n      throw new Error('Cannot set plan after test has ended')\n    }\n\n    if (typeof n !== 'number' || n < 0 || n !== Math.floor(n)) {\n      throw new TypeError('plan must be a non-negative integer')\n    }\n\n    // Cannot get any tests after a trailing plan, or a plan of 0\n    const ending = this.count !== 0 || n === 0\n\n    if (n === 0 && comment && !this.options.skip) {\n      this.options.skip = comment\n    }\n\n    this.#planEnd = n\n    comment = comment ? ' # ' + esc(comment.trim()) : ''\n    this.queue.push('1..' + n + comment + '\\n')\n\n    if (ending) {\n      this.#end(IMPLICIT)\n    } else {\n      this.#process()\n    }\n  }\n\n  /**\n   * A passing (ok) Test Point\n   */\n  pass(...[msg, extra]: MessageExtra) {\n    this.currentAssert = this.pass\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra('(unnamed test)', args)\n    this.printResult(true, ...me)\n    return true\n  }\n\n  /**\n   * A failing (not ok) Test Point\n   */\n  fail(...[msg, extra]: MessageExtra) {\n    this.currentAssert = this.fail\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra('(unnamed test)', args)\n    this.printResult(false, ...me)\n    return !!(me[1].todo || me[1].skip)\n  }\n\n  /**\n   * The current assertion being processed.  May only be set if\n   * not already set.\n   */\n  get currentAssert() {\n    return this.#currentAssert\n  }\n  /**\n   * The current assertion being processed.  May only be set if\n   * not already set.\n   */\n  set currentAssert(fn: null | Function | ((...a: any[]) => any)) {\n    if (!this.#currentAssert && typeof fn === 'function') {\n      this.#currentAssert = fn\n    }\n  }\n\n  /**\n   * Print a Test Point\n   */\n  printResult(\n    ok: boolean,\n    message: string,\n    extra: Extra,\n    front: boolean = false\n  ) {\n    this.currentAssert = this.printResult\n    this.#printedResult = true\n\n    const n = this.count + 1\n    const fn = this.currentAssert\n    this.#currentAssert = null\n\n    if (this.#planEnd !== -1 && n > this.#planEnd) {\n      // prevent infinite regress of \"plan exceeded\" fails\n      if (!this.passing()) return\n\n      // the 'automatic end' can only occur with the root TAP object\n      // and even then, pretty hard to trigger, since it would mean\n      // going several turns of the event loop and hitting it at just\n      // the right time before the process quits.\n      const failMessage = this.#explicitEnded\n        ? 'test assertion after end() was called'\n        : this.#promiseEnded\n        ? 'test assertion after Promise resolution'\n        : this.#explicitPlan\n        ? 'test assertion count exceeds plan'\n        : /* c8 ignore start */\n          'assertion after automatic end'\n      /* c8 ignore stop */\n\n      const er = new Error(failMessage, {\n        cause: {\n          test: this.name,\n          plan: this.#planEnd,\n        },\n      })\n      Error.captureStackTrace(er, fn)\n      this.threw(er, extraFromError(er))\n      return\n    }\n\n    if (extra.expectFail) {\n      ok = !ok\n    }\n\n    if (extra.at === null) {\n      delete extra.at\n      delete extra.stack\n    } else if (\n      typeof extra.stack === 'string' &&\n      extra.stack &&\n      !extra.at\n    ) {\n      const parsed = stack.parseStack(extra.stack)\n      extra.at = parsed[0]\n      extra.stack = parsed.map(c => String(c) + '\\n').join('')\n    } else if (!extra.at && typeof fn === 'function') {\n      const showStack = !ok && !extra.skip && !extra.todo\n      const showAt = showStack || extra.diagnostic === true\n      if (showAt) {\n        const st = stack.capture(80, fn)\n        extra.at = st[0]\n        if (showStack) {\n          extra.stack = st.map(c => String(c)).join('\\n')\n        }\n      }\n    }\n\n    const diagnostic =\n      typeof extra.diagnostic === 'boolean'\n        ? extra.diagnostic\n        : typeof this.diagnostic === 'boolean'\n        ? this.diagnostic\n        : extra.skip || extra.todo\n        ? false\n        : !ok\n\n    if (diagnostic) {\n      extra.diagnostic = true\n    }\n\n    this.count = n\n    message = message + ''\n    const res: Result = { ok, message, extra }\n\n    const tp = new TestPoint(ok, message, extra)\n\n    // when we jump the queue, skip an extra line\n    if (front) {\n      tp.message = tp.message.trimEnd() + '\\n\\n'\n    }\n\n    if (\n      this.#occupied &&\n      this.#occupied instanceof Waiter &&\n      this.#occupied.finishing\n    ) {\n      front = true\n    }\n\n    if (front) {\n      if (extra.tapChildBuffer || extra.tapChildBuffer === '') {\n        this.writeSubComment(tp)\n        this.parser.write(extra.tapChildBuffer)\n      }\n      this.emit('result', res)\n      this.parser.write(tp.ok + ++this.#n + tp.message)\n      if (this.bail && !ok && !extra.skip && !extra.todo) {\n        this.parser.write('Bail out! ' + message + '\\n')\n      }\n    } else {\n      this.queue.push(tp)\n      if (this.bail && !ok && !extra.skip && !extra.todo) {\n        this.queue.push('Bail out! ' + message + '\\n')\n      }\n    }\n\n    if (this.#planEnd === this.count) {\n      this.#end(IMPLICIT)\n    }\n\n    this.#process()\n  }\n\n  end(implicit?: typeof IMPLICIT): this {\n    this.#end(implicit)\n    return this\n  }\n\n  /**\n   * The leading `# Subtest` comment that introduces a child test\n   */\n  writeSubComment<T extends TestPoint | Base>(p: T) {\n    // name will generally always be set\n    /* c8 ignore start */\n    const stn = p.name ? ': ' + esc(p.name) : ''\n    /* c8 ignore stop */\n    const comment = `# Subtest${stn}\\n`\n    this.parser.write(comment)\n  }\n  // end TAP otput generating methods\n\n  // flow control methods\n\n  /**\n   * Await the end of a Promise before proceeding.\n   * The supplied callback is called with the Waiter object.\n   */\n  waitOn(\n    promise: Promise<any | void>,\n    cb?: (w: Waiter) => any,\n    expectReject: boolean = false\n  ): Promise<void> {\n    const w = new Waiter(\n      promise,\n      w => {\n        assert.equal(this.#occupied, w)\n        if (cb) cb(w)\n        this.#occupied = null\n        this.#process()\n      },\n      expectReject\n    )\n    // if the top of the queue is still the version line, we come\n    // in after that. otherwise, it should be the next thing processed.\n    if (this.queue[0] === VERSION) {\n      this.queue.shift()\n      this.queue.unshift(VERSION, w)\n    } else {\n      this.queue.unshift(w)\n    }\n    this.#process()\n    return w.promise\n  }\n\n  #end(implicit?: typeof IMPLICIT) {\n    if (this.#doingStdinOnly && implicit !== IMPLICIT) {\n      throw new Error('cannot explicitly end while in stdinOnly mode')\n    }\n    this.debug('END %s implicit=%j', this.name, implicit === IMPLICIT)\n    if (this.ended && implicit === IMPLICIT) {\n      this.debug('already ended, ignore implicit end')\n      return\n    }\n\n    // If onbeforeend returns a Promise, then wait for it to finish.\n    const obe = this.onbeforeend\n    if (obe && !this.#pushedBeforeEnd) {\n      this.debug('push obe')\n      this.#pushedBeforeEnd = true\n      if (!queueEmpty(this) || this.#occupied) {\n        this.queue.push(obe)\n        this.#process()\n      } else {\n        const ret = obe()\n        if (isPromise(ret)) {\n          // this will make the next section return this.#process()\n          this.waitOn(ret)\n        }\n      }\n    }\n\n    // beyond here we have to be actually done with things, or else\n    // the semantic checks on counts and such will be off.\n    if (!queueEmpty(this) || this.#occupied) {\n      this.debug('#end: queue not empty, or occupied')\n      if (!this.#pushedEnd) {\n        this.queue.push(['#end', implicit])\n      }\n      this.#pushedEnd = true\n      return this.#process()\n    }\n\n    if (implicit !== IMPLICIT) {\n      if (this.#explicitEnded) {\n        if (!this.#multiEndThrew) {\n          this.#multiEndThrew = true\n          const er = new Error(\n            'test end() method called more than once'\n          )\n          Error.captureStackTrace(er, this.#currentAssert || this.end)\n          er.cause = {\n            test: this.name,\n          }\n          this.threw(er)\n        }\n        return\n      }\n      this.debug('set #explicitEnded=true')\n      this.#explicitEnded = true\n    }\n\n    this.debug('set ended=true')\n    this.ended = true\n\n    if (this.#planEnd === -1 && !this.#doingStdinOnly) {\n      this.debug('END(%s) implicit plan', this.name, this.count)\n      this.plan(this.count, '', IMPLICIT)\n    }\n\n    this.queue.push(EOF)\n    this.#process()\n  }\n\n  get fullname(): string {\n    const main = (\n      mainScript('TAP') +\n      ' ' +\n      argv.slice(2).join(' ')\n    ).trim()\n    const n: string[] = [\n      (this.parent\n        ? this.parent.fullname\n        : main === 'TAP'\n        ? 'TAP'\n        : relative(cwd, main).replace(/\\\\/g, '/')\n      ).trim(),\n    ]\n    // tests will generally always have a name\n    /* c8 ignore start */\n    const myName = (this.name || '').trim()\n    /* c8 ignore stop */\n    if (myName) n.push(myName)\n    return n.join(' > ')\n  }\n\n  #process() {\n    if (this.#processing) {\n      return this.debug(' < already processing')\n    }\n    this.debug('\\nPROCESSING(%s)', this.name, this.queue.length)\n    this.#processing = true\n\n    while (!this.#occupied) {\n      const p = this.queue.shift()\n      if (!p) {\n        this.debug('> end of queue')\n        break\n      }\n      if (p instanceof Base) {\n        this.debug('> subtest in queue', p.name)\n        this.#processSubtest(p)\n      } else if (p === EOF) {\n        this.debug(' > EOF', this.name)\n        if (!this.#calledOnEOF) {\n          this.#calledOnEOF = true\n          // I AM BECOME EOF, DESTROYER OF STREAMS\n          this.debug('call onEOF', this.name)\n          const eofRet = this.onEOF()\n          if (isPromise(eofRet)) {\n            this.debug('onEOF is promise')\n            this.waitOn(eofRet, w => {\n              if (w.rejected) {\n                // threw on the parent, since we're EOFing already\n                this.debug('eofRet reject', w.value)\n                this.comment('error thrown in teardown')\n                this.threw(w.value)\n              }\n              this.queue.push(EOF)\n              this.#process()\n            })\n            break\n          }\n        }\n        this.debug('eof end parser', this.name)\n        this.parser.end()\n      } else if (p instanceof TestPoint) {\n        this.debug(' > TESTPOINT')\n        if (p.extra.tapChildBuffer || p.extra.tapChildBuffer === '') {\n          this.writeSubComment(p)\n          this.parser.write(p.extra.tapChildBuffer)\n        }\n        this.emit('res', p.res)\n        this.parser.write(p.ok + ++this.#n + p.message)\n      } else if (typeof p === 'string') {\n        this.debug(' > STRING')\n        this.parser.write(p)\n      } else if (p instanceof Waiter) {\n        p.ready = true\n        this.#occupied = p\n        p.finish()\n      } else if (typeof p === 'function') {\n        this.debug(' > FUNCTION')\n        const ret = p()\n        if (isPromise(ret)) {\n          this.waitOn(ret)\n        }\n      } else if (Array.isArray(p)) {\n        this.debug(' > METHOD')\n        const m = p.shift() as keyof this\n        const fn = (m === '#end' ? this.#end : this[m]) as (\n          ...a: any[]\n        ) => any\n        if (typeof fn !== 'function') {\n          this.debug(\n            ' > weird method not found in queue??',\n            m,\n            typeof this[m]\n          )\n          continue\n        }\n        const ret = fn.call(this, ...p)\n        if (isPromise(ret)) {\n          // returned promise\n          ret.then(\n            () => {\n              this.#processing = false\n              this.#process()\n            },\n            (er: unknown) => {\n              this.#processing = false\n              this.threw(er)\n            }\n          )\n          return\n        }\n        /* c8 ignore start */\n      } else {\n        throw new Error('weird thing got in the queue')\n      }\n      /* c8 ignore stop */\n    }\n\n    while (!this.#noparallel && this.pool.size < this.jobs) {\n      const p = this.subtests.shift()\n      if (!p) {\n        break\n      }\n\n      if (!p.buffered) {\n        this.#noparallel = true\n        break\n      }\n\n      this.debug('start subtest', p)\n      this.emit('subtestStart', p)\n      this.pool.add(p)\n      if (this.bailedOut) {\n        this.#onBufferedEnd(p)\n      } else {\n        p.runMain(() => this.#onBufferedEnd(p))\n      }\n    }\n\n    this.debug('done processing', this.queue, this.#occupied)\n    this.#processing = false\n\n    // just in case any tests ended, and we have sync stuff still\n    // waiting around in the queue to be processed\n    if (!this.#occupied && this.queue.length) {\n      this.#process()\n    } else if (this.idle) {\n      // the root tap runner uses this event to know when it is safe to\n      // automatically end.\n      this.emit('idle')\n    }\n  }\n\n  get idle() {\n    return (\n      !this.#processing &&\n      queueEmpty(this) &&\n      !this.pool.size &&\n      !this.subtests.length &&\n      !this.#occupied &&\n      // if we have a plan, don't autoend until the plan is complete.\n      this.#planEnd === -1\n    )\n  }\n\n  #onBufferedEnd<T extends Base>(p: T) {\n    p.ondone = p.constructor.prototype.ondone\n    p.results = p.results || new FinalResults(true, p.parser)\n    p.readyToProcess = true\n    const to = p.options.timeout\n    const dur =\n      to && p.passing()\n        ? Number(hrtime.bigint() - p.start) / 1e6\n        : null\n    if (dur && to && dur > to) {\n      p.timeout()\n    } else {\n      p.setTimeout(0)\n    }\n    this.debug(\n      '%s.#onBufferedEnd',\n      this.name,\n      p.name,\n      p.results.bailout\n    )\n    this.pool.delete(p)\n    p.options.tapChildBuffer = p.output || ''\n    p.options.stack = ''\n    if (p.time) p.options.time = p.time\n    if (this.#occupied === p) this.#occupied = null\n    p.deferred?.resolve(p.results)\n    this.emit('subtestEnd', p)\n    this.#process()\n  }\n\n  #onIndentedEnd<T extends Base>(p: T) {\n    this.debug('onIndentedEnd', p.name)\n    this.emit('subtestProcess', p)\n    p.ondone = p.constructor.prototype.ondone\n    // we'll generally already have a results by now, but just to be sure\n    /* c8 ignore start */\n    p.results = p.results || new FinalResults(true, p.parser)\n    /* c8 ignore stop */\n    this.#noparallel = false\n    const sti = this.subtests.indexOf(p)\n    if (sti !== -1) this.subtests.splice(sti, 1)\n    p.readyToProcess = true\n    p.options.time = p.time\n    const to = p.options.timeout\n    const dur = to && p.passing() ? hrtime.bigint() - p.start : null\n    if (dur && to && dur > to) {\n      p.timeout()\n    } else {\n      p.setTimeout(0)\n    }\n    this.debug('#onIndentedEnd %s(%s)', this.name, p.name)\n    this.#occupied = null\n    this.debug('OIE(%s) >shift into queue', this.name, this.queue)\n    p.options.stack = ''\n\n    this.printResult(p.passing(), p.name, p.options, true)\n\n    this.debug('OIE(%s) shifted into queue', this.name, this.queue)\n    p.deferred?.resolve(p.results)\n    this.emit('subtestEnd', p)\n    this.#process()\n  }\n\n  /**\n   * @internal\n   */\n  main(cb: () => void) {\n    if (typeof this.options.timeout === 'number') {\n      this.setTimeout(this.options.timeout)\n    }\n    this.debug('MAIN pre', this.name)\n\n    const end = () => {\n      this.debug(' > implicit end for promise')\n      this.#promiseEnded = true\n      this.#end(IMPLICIT)\n      done()\n    }\n\n    const done = (er?: Error) => {\n      if (er) this.threw(er)\n\n      if (this.results || this.bailedOut) cb()\n      else this.ondone = () => cb()\n    }\n\n    // This bit of overly clever line-noise wraps the call to user-code\n    // in a try-catch. We can't rely on the domain for this yet, because\n    // the 'end' event can trigger a throw after the domain is unhooked,\n    // but before this is no longer the official \"active test\"\n    const ret = (() => {\n      if (!this.cb) return\n      try {\n        return this.cb(this.t || this)\n      } catch (er: any) {\n        if (!er || typeof er !== 'object') {\n          er = { error: er, at: null }\n        }\n        er.tapCaught = 'testFunctionThrow'\n        this.threw(er)\n      }\n    })()\n\n    if (ret && ret.then) {\n      this.donePromise = ret\n      ret.tapAbortPromise = done\n      ret.then(end, (er: any) => {\n        if (!er || typeof er !== 'object') {\n          er = { error: er, at: null }\n        }\n        er.tapCaught = 'returnedPromiseRejection'\n        done(er)\n      })\n    } else done()\n\n    this.debug('MAIN post', this.name)\n  }\n\n  #processSubtest<T extends Base>(p: T) {\n    this.debug('processSubtest', p.name)\n    this.debug(' > subtest')\n    this.#occupied = p\n    if (!p.buffered) {\n      this.emit('subtestStart', p)\n      this.debug(' > subtest indented')\n      p.pipe(this.parser, { end: false })\n      this.writeSubComment(p)\n      this.debug('calling runMain', p.name)\n      p.runMain(() => {\n        this.debug('runMain callback', p.name)\n        this.#onIndentedEnd(p)\n      })\n    } else if (p.readyToProcess) {\n      this.emit('subtestProcess', p)\n      this.debug(' > subtest buffered, finished')\n      // finished!  do the thing!\n      this.#occupied = null\n      if (!p.passing() || !p.silent) {\n        this.printResult(p.passing(), p.name, p.options, true)\n      }\n    } else {\n      this.#occupied = p\n      this.debug(' > subtest buffered, unfinished', p)\n      // unfinished buffered test.\n      // nothing to do yet, just leave it there.\n      this.queue.unshift(p)\n    }\n  }\n\n  /**\n   * Parse stdin as the only tap stream (ie, not as a child test)\n   * If used, then no other subtests or assertions are allowed.\n   */\n  stdinOnly<T extends BaseOpts>(\n    extra?: T & { tapStream?: Readable | Minipass<string | Buffer> }\n  ) {\n    const stream = (extra?.tapStream ?? process.stdin) as Minipass\n    /* c8 ignore start */\n    if (!stream) {\n      throw new Error('cannot read stdin without stdin stream')\n    }\n    /* c8 ignore stop */\n\n    if (\n      this.queue.length !== 1 ||\n      this.queue[0] !== VERSION ||\n      this.#processing ||\n      this.results ||\n      this.#occupied ||\n      this.pool.size ||\n      this.subtests.length\n    ) {\n      throw new Error('Cannot use stdinOnly on a test in progress')\n    }\n\n    this.#doingStdinOnly = true\n    this.queue.length = 0\n    this.parser.on('child', p => {\n      // pretend to be a rooted parser, so it gets counts.\n      p.root = p\n      const t = new Base({\n        name: p.name,\n        parent: this,\n        parser: p,\n        bail: p.bail,\n        strict: p.strict,\n        omitVersion: p.omitVersion,\n        preserveWhitespace: p.preserveWhitespace,\n        childId: this.#nextChildId++,\n      })\n      this.emit('subtestAdd', t)\n      this.emit('subtestStart', t)\n      this.emit('subtestProcess', t)\n      p.on('complete', () => {\n        t.time = p.time\n        this.emit('subtestEnd', t)\n      })\n    })\n    stream.pipe(this.parser)\n    stream.resume()\n  }\n\n  /**\n   * Mount a subtest, using this Test object as a harness.\n   * Exposed mainly so that it can be used by builtin plugins.\n   *\n   * @internal\n   */\n  sub<T extends Base, O extends BaseOpts>(\n    Class: { new (options: O): T },\n    extra: O | TestOpts | TestBaseOpts | BaseOpts = {},\n    caller: (...a: any[]) => unknown\n  ): PromiseWithSubtest<T> {\n    if (this.bailedOut) {\n      return Object.assign(Promise.resolve(null), {\n        subtest: null,\n      })\n    }\n\n    if (this.results || this.ended) {\n      const er = new Error(\n        'cannot create subtest after parent test ends'\n      )\n      Error.captureStackTrace(er, caller)\n      this.threw(er)\n      return Object.assign(Promise.resolve(null), {\n        subtest: null,\n      })\n    }\n\n    extra.childId = this.#nextChildId++\n    if (this.shouldSkipChild(extra)) {\n      this.pass(extra.name || '', extra)\n      return Object.assign(Promise.resolve(null), {\n        subtest: null,\n      })\n    }\n\n    extra.indent = '    '\n    if (extra.buffered === undefined) {\n      if (this.jobs > 1) {\n        extra.buffered = true\n      } else {\n        extra.buffered = false\n      }\n    }\n\n    extra.bail = extra.bail !== undefined ? extra.bail : this.bail\n    extra.parent = this\n    if (!extra.at && extra.at !== null) {\n      const st = stack.capture(80, caller)\n      extra.at = st[0]\n      extra.stack = st.map(c => String(c)).join('\\n')\n    }\n    extra.context = this.context\n\n    const t = new Class(extra as O)\n    this.queue.push(t)\n    this.subtests.push(t)\n    this.emit('subtestAdd', t)\n\n    const d = new Deferred<FinalResults>()\n    t.deferred = d\n    this.#process()\n    return Object.assign(d.promise, { subtest: t })\n  }\n\n  threw(\n    er: any,\n    extra?: Extra,\n    proxy: boolean = false\n  ): Extra | void | undefined {\n    this.debug('TestBase.threw', this.name, er.message)\n    // this can happen if a beforeEach throws.  capture the error here\n    // and raise it once we've started the test officially.\n    if (this.parent && !this.started) {\n      this.cb = () => {\n        this.threw(er)\n        this.end()\n      }\n      return\n    }\n\n    // suppress the callsite for non-error throws, since\n    // it'll always just be useless noise pointing back here.\n    if (!er || typeof er !== 'object') {\n      er = { error: er, at: null }\n    }\n\n    if (this.name && !proxy) {\n      er.test = this.name\n    }\n    if (!proxy) {\n      extra = extraFromError(er, extra)\n    }\n    this.debug('T.t call Base.threw', this.name, extra)\n    const ended =\n      !!this.results ||\n      // should be impossible, when we hit the plan end, we end\n      /* c8 ignore start */\n      (this.#explicitPlan && this.count === this.#planEnd)\n    /* c8 ignore stop */\n    this.parser.ok = false\n    super.threw(er, extra, proxy, ended)\n\n    // Handle the failure here, but only if we (a) don't have\n    // results yet (indicating an end) and (b) are not currently\n    // at the plan end (which would mean that any failure is\n    // ignored to prevent infinite regress in \"plan exceeded\"\n    // failures)\n    if (!ended) {\n      const msg =\n        typeof extra?.message === 'string'\n          ? extra.message\n          : typeof er.message === 'string'\n          ? er.message\n          : er.stack\n          ? er.stack.split('\\n')[0]\n          : typeof er.error === 'string'\n          ? er.error\n          : ''\n      extra ??= { at: null }\n      if (msg === '') extra.at = null\n      if (er.stack) {\n        const p = stack.parseStack(er.stack)\n        extra.at = p[0]\n        extra.stack = p.map(c => String(c) + '\\n').join('')\n      }\n      this.fail(msg, extra)\n      if (this.ended || this.#pushedEnd) {\n        this.ended = false\n        this.#pushedEnd = false\n        this.end(IMPLICIT)\n      }\n    }\n    if (this.#occupied && this.#occupied instanceof Waiter) {\n      this.#occupied.abort(\n        Object.assign(\n          new Error('error thrown while awaiting Promise'),\n          { thrown: er }\n        )\n      )\n      this.#occupied = null\n    }\n    if (!proxy) {\n      this.#end(IMPLICIT)\n      this.#processing = false\n    }\n\n    this.#process()\n  }\n\n  onbail(message?: string) {\n    super.onbail(message)\n    this.#end(IMPLICIT)\n    if (!this.parent) {\n      this.endAll()\n    }\n  }\n\n  endAll(sub: boolean = false) {\n    if (this.bailedOut) return\n\n    // in the case of the root TAP test object, we might sometimes\n    // call endAll on a bailing-out test, as the process is ending\n    // In that case, we WILL have a this.occupied and a full queue\n    // These cases are very rare to encounter in other Test objs tho\n    this.#processing = true\n    if (this.#occupied) {\n      const p = this.#occupied\n      if (p instanceof Waiter) p.abort(new Error('test unfinished'))\n      else if (typeof (p as TestBase).endAll === 'function')\n        (p as TestBase).endAll(true)\n      else p.parser.abort('test unfinished')\n      this.#occupied = null\n    } else if (sub) {\n      this.#process()\n      if (queueEmpty(this)) {\n        const options = Object.assign({}, this.options)\n        options.test = this.name\n        this.fail('test unfinished', options)\n      }\n    }\n\n    if (this.donePromise && this.donePromise.tapAbortPromise)\n      this.donePromise.tapAbortPromise()\n\n    for (let i = 0; i < this.queue.length; i++) {\n      const p = this.queue[i]\n      if (p instanceof Base && !p.readyToProcess) {\n        const msg = `child test left in queue: ${p.name}`\n        this.queue[i] = new TestPoint(false, msg, p.options)\n        this.count++\n      }\n    }\n\n    this.#processing = false\n    this.#end(IMPLICIT)\n  }\n\n  /**\n   * Return true if the child test represented by the options object\n   * should be skipped.  Extended by the grep/only filtering plugins.\n   */\n  shouldSkipChild(\n    extra: TestOpts | TestBaseOpts | BaseOpts\n  ): boolean {\n    return !!(extra.skip || extra.todo)\n  }\n}\n"]}