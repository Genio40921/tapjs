{"version":3,"file":"parse-test-args.js","sourceRoot":"","sources":["../../src/parse-test-args.ts"],"names":[],"mappings":"AAoBA,MAAM,CAAC,MAAM,aAAa,GAAG,CAC3B,GAAG,IAAiB,EACV,EAAE;IACZ,IAAI,IAAI,GAA8B,SAAS,CAAA;IAC/C,IAAI,KAAK,GACP,SAAS,CAAA;IACX,IAAI,EAAE,GAAuC,SAAS,CAAA;IAEtD,sDAAsD;IACtD,mBAAmB;IACnB,MAAM,WAAW,GAAG,IAAI,CAAC,CAAC,CAAC,IAAI,EAAE,CAAA;IAEjC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QAC7C,MAAM,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,CAAA;QACnB,IACE,IAAI,KAAK,SAAS;YAClB,CAAC,OAAO,GAAG,KAAK,QAAQ,IAAI,OAAO,GAAG,KAAK,QAAQ,CAAC;YAEpD,IAAI,GAAG,EAAE,GAAG,GAAG,CAAA;aACZ,IAAI,GAAG,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;YACvC,KAAK,GAAG,GAAG,CAAA;YACX,IAAI,IAAI,KAAK,SAAS;gBAAE,IAAI,GAAG,IAAI,CAAA;SACpC;aAAM,IAAI,OAAO,GAAG,KAAK,UAAU,EAAE;YACpC,IAAI,KAAK,KAAK,SAAS;gBAAE,KAAK,GAAG,EAAE,CAAA;YACnC,IAAI,IAAI,KAAK,SAAS;gBAAE,IAAI,GAAG,IAAI,CAAA;YACnC,EAAE,GAAG,GAAG,CAAA;SACT;aAAM,IAAI,GAAG,KAAK,KAAK,EAAE;YACxB,uDAAuD;YACvD,2CAA2C;YAC3C,SAAQ;SACT;aAAM,IAAI,OAAO,GAAG,KAAK,WAAW;YACnC,MAAM,IAAI,SAAS,CACjB,4CAA4C;gBAC1C,OAAO,GAAG,CACb,CAAA;KACJ;IAED,IAAI,CAAC,KAAK;QAAE,KAAK,GAAG,EAAE,CAAA;IAEtB,IAAI,CAAC,EAAE,IAAI,WAAW,KAAK,YAAY,EAAE;QACvC,KAAK,CAAC,IAAI,GAAG,KAAK,CAAC,IAAI,IAAI,IAAI,CAAA;KAChC;IAED,IAAI,CAAC,IAAI,IAAI,KAAK,CAAC,IAAI;QAAE,IAAI,GAAG,KAAK,CAAC,IAAI,CAAA;IAE1C,IAAI,CAAC,IAAI,IAAI,EAAE,IAAI,EAAE,CAAC,IAAI;QAAE,IAAI,GAAG,EAAE,CAAC,IAAI,CAAA;IAE1C,IAAI,GAAG,IAAI,IAAI,WAAW,CAAA;IAC1B,KAAK,CAAC,IAAI,GAAG,IAAI,CAAA;IACjB,MAAM,IAAI,GAAG,KAAiB,CAAA;IAC9B,IAAI,CAAC,EAAE,GAAG,EAAE,IAAI,MAAM,CAAA;IACtB,OAAO,IAAI,CAAA;AACb,CAAC,CAAA;AAED,MAAM,MAAM,GAAG,GAAG,EAAE;IAClB,MAAM,IAAI,KAAK,CAAC,+BAA+B,CAAC,CAAA;AAClD,CAAC,CAAA","sourcesContent":["import type { Base, BaseOpts } from './base.js'\n\nimport { TestOpts } from '@tapjs/test'\n\nexport type TestArgs<T extends Base> =\n  | [\n      name?: string | number,\n      extra?: TestOpts | BaseOpts,\n      cb?: false | ((t: T) => any),\n      defaultName?: string\n    ]\n  | [\n      extra: TestOpts | BaseOpts,\n      cb?: ((t: T) => any) | false\n    ]\n  | [name: string | number, cb?: ((t: T) => any) | false]\n  | [cb?: ((t: T) => any) | false]\n  | [name: string]\n  | [extra: TestOpts | BaseOpts]\n\nexport const parseTestArgs = <T extends Base>(\n  ...args: TestArgs<T>\n): TestOpts => {\n  let name: string | null | undefined = undefined\n  let extra: TestOpts | BaseOpts | null | undefined =\n    undefined\n  let cb: ((t: T) => any) | null | undefined = undefined\n\n  // this only works if it's literally the 4th argument.\n  // used internally.\n  const defaultName = args[3] || ''\n\n  for (let i = 0; i < 3 && i < args.length; i++) {\n    const arg = args[i]\n    if (\n      name === undefined &&\n      (typeof arg === 'string' || typeof arg === 'number')\n    )\n      name = '' + arg\n    else if (arg && typeof arg === 'object') {\n      extra = arg\n      if (name === undefined) name = null\n    } else if (typeof arg === 'function') {\n      if (extra === undefined) extra = {}\n      if (name === undefined) name = null\n      cb = arg\n    } else if (arg === false) {\n      // it's handy while developing to put a ! in front of a\n      // function to temporarily make a test todo\n      continue\n    } else if (typeof arg !== 'undefined')\n      throw new TypeError(\n        'unknown argument passed to parseTestArgs: ' +\n          typeof arg\n      )\n  }\n\n  if (!extra) extra = {}\n\n  if (!cb && defaultName !== '/dev/stdin') {\n    extra.todo = extra.todo || true\n  }\n\n  if (!name && extra.name) name = extra.name\n\n  if (!name && cb && cb.name) name = cb.name\n\n  name = name || defaultName\n  extra.name = name\n  const opts = extra as TestOpts\n  opts.cb = cb || todoCb\n  return opts\n}\n\nconst todoCb = () => {\n  throw new Error('callback called for TODO test')\n}\n"]}