{"version":3,"file":"spawn.js","sourceRoot":"","sources":["../../src/spawn.ts"],"names":[],"mappings":"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","sourcesContent":["import { Base, TapBaseEvents } from './base.js'\n\nimport { ProcessInfo } from '@tapjs/processinfo'\nimport { WithExternalID } from '@tapjs/processinfo'\nimport {\n  ChildProcess,\n  ChildProcessByStdio,\n  IOType,\n  SpawnOptions,\n  StdioOptions,\n} from 'node:child_process'\nimport { basename } from 'node:path'\nimport { Readable, Stream, Writable } from 'node:stream'\nimport { TestBaseOpts } from './test-base.js'\n\nexport type ChildProcessWithStdout = ChildProcessByStdio<\n  null | Writable,\n  Readable,\n  null | Readable\n>\n\nconst hasStdout = (p: ChildProcess): p is ChildProcessWithStdout =>\n  !!p.stdout\n\nexport interface SpawnEvents extends TapBaseEvents {\n  preprocess: [WithExternalID<SpawnOptions>]\n  process: [ChildProcessWithStdout]\n}\n\nexport interface SpawnOpts extends TestBaseOpts {\n  cwd?: string\n  command?: string\n  args?: string[]\n  /**\n   * Passed to child_process.spawn's 'stdio' option\n   *\n   * No matter what is specified here, stdout is *always* set to 'pipe',\n   * and stdio[3] is *always* set to 'ipc', because TAP uses these internally\n   * to communicate test results and timeout, respectively.\n   *\n   * So, this is only to set the behavior of stdin and stderr.\n   */\n  stdio?: StdioOptions\n  env?: { [k: string]: string } | typeof process.env\n  exitCode?: number | null\n  signal?: string | null\n}\n\nexport class Spawn extends Base<SpawnEvents> {\n  declare options: SpawnOpts\n  cwd: string\n  command: string\n  args: string[]\n  stdio: [\n    IOType | Stream | number | null | undefined,\n    'pipe',\n    IOType | Stream | number | null | undefined,\n    'ipc'\n  ]\n  env: { [k: string]: string } | typeof process.env\n  proc: null | ChildProcess\n  cb: null | (() => void)\n\n  // doesn't have to be cryptographically secure, just a gut check\n  #tapAbortKey: string = String(Math.random())\n\n  #childId: string\n\n  constructor(options: SpawnOpts) {\n    // figure out the name before calling super()\n    const command = options.command\n    if (!command) {\n      throw new TypeError('no command provided for t.spawn()')\n    }\n    options = options || {}\n    const cwd =\n      typeof options.cwd === 'string' ? options.cwd : process.cwd()\n    const args = options.args || []\n\n    options.name = options.name || Spawn.procName(cwd, command, args)\n    super(options)\n\n    this.cwd = cwd\n    this.command = command\n    this.args = args\n    if (options.stdio) {\n      if (typeof options.stdio === 'string') {\n        this.stdio = [options.stdio, 'pipe', options.stdio, 'ipc']\n      } else {\n        const [stdin, _, stderr] = options.stdio\n        /* c8 ignore start */\n        if (stdin === 'ipc' || stderr === 'ipc') {\n          throw new Error(\n            'cannot spawn subtest with ipc in stdin or stderr'\n          )\n        }\n        /* c8 ignore stop */\n        this.stdio = [stdin, 'pipe', stderr, 'ipc']\n      }\n    } else {\n      this.stdio = [0, 'pipe', 2, 'ipc']\n    }\n\n    const env = options.env || process.env\n    this.#childId = String(options.childId || env.TAP_CHILD_ID || '0')\n    this.env = {\n      ...env,\n      TAP_CHILD_ID: this.#childId,\n      TAP: '1',\n      TAP_BAIL: this.bail ? '1' : '0',\n      TAP_ABORT_KEY: this.#tapAbortKey,\n    }\n\n    this.proc = null\n    this.cb = null\n  }\n\n  endAll() {\n    if (this.proc) {\n      this.proc.kill('SIGKILL')\n      this.parser.abort('test unfinished')\n    }\n    this.#callCb()\n  }\n\n  #callCb() {\n    if (this.cb) {\n      this.cb()\n    }\n    this.cb = null\n  }\n\n  main(cb: () => void) {\n    this.cb = cb\n    this.setTimeout(this.options.timeout || 0)\n\n    this.parser.on('comment', c => {\n      const tomatch = c.match(/# timeout=([0-9]+)\\n$/)\n      if (tomatch) {\n        this.setTimeout(+tomatch[1])\n      }\n    })\n\n    const options = {\n      cwd: this.cwd,\n      env: this.env,\n      stdio: this.stdio,\n      externalID: this.name,\n    }\n    this.parent?.emit('spawn', this)\n\n    this.emit('preprocess', options)\n    const proc = (this.proc = ProcessInfo.spawn(\n      this.command,\n      this.args,\n      options\n    ))\n    /* c8 ignore start */\n    if (!hasStdout(proc)) {\n      return this.threw(\n        'failed to open child process stdout',\n        this.options\n      )\n    }\n    /* c8 ignore stop */\n    proc.stdout.pipe(this.parser)\n    try {\n      //@ts-ignore\n      proc.stdio[3]?.unref()\n    } catch (_) {}\n    proc.on('close', (code, signal) => {\n      this.#onprocclose(code, signal)\n    })\n    proc.on('error', er => this.threw(er))\n    this.emit('process', proc)\n  }\n\n  #onprocclose(code: number | null, signal: string | null) {\n    this.debug('SPAWN close %j %s', code, signal)\n    this.options.exitCode = code\n    this.options.signal = signal\n\n    // spawn closing with no tests is treated as a skip.\n    if (\n      this.results &&\n      this.results.plan &&\n      this.results.plan.skipAll &&\n      !code &&\n      !signal\n    ) {\n      this.options.skip = this.results.plan.skipReason || true\n    }\n\n    if (code || signal) {\n      if (this.results) {\n        this.results.ok = false\n      }\n      this.parser.ok = false\n    }\n    return this.#callCb()\n  }\n\n  timeout(options: { expired?: string } = { expired: this.name }) {\n    // try to send the timeout signal.  If the child test process is\n    // using node-tap as the test runner, and not caught in a busy\n    // loop, it will trigger a dump of outstanding handles and refs.\n    // If that doesn't do the job, then we fall back to signals.\n    // Unfortunately, termination signals on windows cannot be caught,\n    // so this is the only way to get that information in most cases.\n    const proc = this.proc\n    if (proc) {\n      try {\n        proc.send({\n          tapAbort: 'timeout',\n          key: this.#tapAbortKey,\n          child: this.#childId,\n        })\n        /* c8 ignore start */\n      } catch (_) {}\n      /* c8 ignore stop */\n      const t = setTimeout(() => {\n        // try to give it a chance to note the timeout and report handles\n        try {\n          proc.kill('SIGALRM')\n        } catch (er) {}\n        const t = setTimeout(() => {\n          const { signal, exitCode } = this.options\n          if (!signal && exitCode === undefined) {\n            super.timeout(options)\n            // that didn't work, use forceful termination\n            proc.kill('SIGKILL')\n          }\n        }, 500)\n        /* c8 ignore start */\n        if (t.unref) t.unref()\n        /* c8 ignore stop */\n      }, 500)\n      /* c8 ignore start */\n      if (t.unref) t.unref()\n      /* c8 ignore stop */\n    }\n  }\n\n  static procName(cwd: string, command: string, args: string[]) {\n    return (\n      command === process.execPath\n        ? basename(process.execPath) +\n          ' ' +\n          args\n            .map(a =>\n              a.indexOf(cwd) === 0\n                ? './' +\n                  a.substring(cwd.length + 1).replace(/\\\\/g, '/')\n                : a\n            )\n            .join(' ')\n            .trim()\n        : command + ' ' + args.join(' ')\n    ).replace(/\\\\/g, '/')\n  }\n}\n"]}